<!DOCTYPE HTML>
<!--
    Future Imperfect by HTML5 UP
    html5up.net | @n33co
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Tech 4 R&D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Hugo Ferreira">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <link rel="stylesheet" href="../css/google-font.css" />
    <link rel="stylesheet" href="../css/font-awesome.min.css" />
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/main.css" />
    <link rel="stylesheet" href="../css/add-on.css" />
    <!--<link rel="stylesheet" href="../css/monokai-sublime.css">-->
    <!--<link rel="stylesheet" href="../css/hljs_lioshi.min.css">-->
    <!--<link rel="stylesheet" href="../css/hljs_googlecode.min.css">  -->
    <!--<link rel="stylesheet" href="../css/hljs_default-dark.min.css">-->
    <!--<link rel="stylesheet" href="../css/hljs_tomorrow-night-blue.min.css">-->
    <!--<link rel="stylesheet" href="../css/hljs_magula.min.css">-->
    <!--<link rel="stylesheet" href="../css/hljs_docco.min.css">-->

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../img/favicon/favicon.png">
  </head>
  <body>
     <!-- Wrapper -->
        <div id="wrapper">
	
<!-- Header -->
<header id="header">
            <h2><a href="http://www.jbake.org">Tech 4 R&D</i></a></h2>

    <nav class="links">
        <ul>
        			<li>
	                    <a href=" http://www.jbake.org">
	                       
	                            <i class="fa fa-home">&nbsp;</i>Home
	                        
	                    </a>
                	</li>
        		
        		 
        			<li>
	                    <a href=" ../archive.html">
	                       
	                            <i class="fa fa-archive">&nbsp;</i>Archive
	                        
	                    </a>
                	</li>
        		
        		 
        			<li>
	                    <a href=" ../about.html">
	                       
	                            <i class="fa fa-user">&nbsp;</i>About
	                        
	                    </a>
                	</li>
        		
        		 
        			<li>
	                    <a href=" ../feed.xml">
	                       
	                            <i class="fa fa-rss">&nbsp;</i>Subscribe
	                        
	                    </a>
                	</li>
        		
        		 
        </ul>
    </nav>
    <nav class="main">
        <ul>
            <li>
                <div>
                    <input type="checkbox" class="checkbox" id="mode_checkbox">
                    <label for="mode_checkbox" class="label">
                        <div class='ball'>
                    </label>
                </div>
            </li>
            <li class="search">
                <a class="fa-search" href="#search">Search</a>
                <form id="search" method="get" action="//google.com/search">
                    <input type="text" name="q" placeholder="Search" />
                    <input type="hidden" name="q" value="site:http://www.jbake.org">
                </form>
            </li>
            <li class="menu">
                <a class="fa-bars" href="#menu">Menu</a>
            </li>
        </ul>
    </nav>
</header>

<!-- Menu -->
<section id="menu">

    <!-- Search -->
        <section>
            <form class="search" method="get" action="//google.com/search">
                <input type="text" name="q" placeholder="Search" />
                <input type="hidden" name="q" value="site:http://www.jbake.org">
            </form>
        </section>

    <!-- Links -->
        <section>
            <ul class="links">
        		 <li>
                    <a href=" http://www.jbake.org">
                       
                            <i class="fa fa-home">&nbsp;</i>Home
                        
                    </a>
                </li>
        		 <li>
                    <a href=" ../archive.html">
                       
                            <i class="fa fa-archive">&nbsp;</i>Archive
                        
                    </a>
                </li>
        		 <li>
                    <a href=" ../about.html">
                       
                            <i class="fa fa-user">&nbsp;</i>About
                        
                    </a>
                </li>
        		 <li>
                    <a href=" ../feed.xml">
                       
                            <i class="fa fa-rss">&nbsp;</i>Subscribe
                        
                    </a>
                </li>
            </ul>
        </section>

    <!-- Recent Posts -->
        <section>
            <ul class="links">
                <header>
                    <h3>Recent Posts</h3>
                </header>
                    <li>
                        <a href="../../blog/2020/mill/jbake/mill_mdoc_part_1.html"><p>Tutorial: Publishing your own Github blog</p></a>
                    </li>
                    <li>
                        <a href="../../blog/2020/mill/javafx/javafx.html"><p>Tutorial: JavaFX Mill project</p></a>
                    </li>
            </ul>
        </section>

    <!-- Actions -->
        <!--
        <section>
            <ul class="actions vertical">
                <li><a href="#" class="button big fit">Log In</a></li>
            </ul>
        </section>
        -->
</section>
	
	<div id="main">
<article class="post">
   <header>
    <div class="title">
                    <h2><a href="../blog/2020/mill/javafx/javafx.html">Tutorial: JavaFX Mill project</a></h2>


            <p>Using Mill to set-up an OpenJFX (formerly JavaFX) Java or Scala application</p>
    </div>
    <div class="meta">
         <time class="published"
            datetime='Jun 09, 2022'>
            Jun 09, 2022</time>
            <div class="published eta"></div>
        <span class="author"/><span class="name">Hugo Ferreira</span><img src="../img/main/avatar.png" alt="Hugo Ferreira" /></span>
    </div>
</header>

    
  
         
    <div id="content">
       <!-- cSpell:ignore javac, jpms, Haoyi, Roeser, Coursier, SBuild, println, controlsfx, javafx, helloworld, scalac ---> <!-- cSpell:ignore hamcrest, scalameta, munit, classpath, IntelliJ, unmanage, inkscape, inkview, lihaoyi, centerme ---> <!-- https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown --> <!-- https://opensource.com/article/17/7/4-lightweight-image-viewers-linux-desktop --> <!-- https://github.com/streetsidesoftware/vscode-spell-checker/issues/117 --> 
<style>
b  { color: Black  }
r  { color: Red    }
o  { color: Orange }
g  { color: Green  }
gr { color: Gray   }
bw { background-color: White }
</style> 
<h1>Introduction</h1> 
<p>In this article I am going to show you how to use <a href="https://github.com/com-lihaoyi/mill"><code>Mill</code></a> to set-up a <code>Java</code> and a <code>Scala</code> application that both use <a href="https://openjfx.io/"><code>OpenJFX</code></a>(previously JavaFX). The motivation behind this article is that, although planned, <a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html"><code>Scala</code> does not support JPMS modules</a>. This is also true of other JVM languages. Java does provide backward compatibility by allowing <em>"legacy developers"</em> to use standard Jar libraries as unnamed modules for JDK 9 and above. However, this is fraught with <a href="https://developer.ibm.com/tutorials/java-modularity-5/">difficulties</a>. In particular, <a href="https://users.scala-lang.org/t/solved-does-dotty-support-javas-jigsaw/6561/5">OpenJFX</a> requires some hacks that don't always seem to work. This article also serves as a tutorial for those of you are unfamiliar with Mill. I will explain and demonstrate the use of Mill step by step.</p> 
<p>All the code and scripts are available in <a href="https://github.com/hmf/javaFXMill">this Github repository</a>. This <code>Mill</code> project supports both Scala 2 and Scala 3. This has been tested with JDK 11 and JDK 17. You need only change the build script to use the desired version of Scala and Java. Before we get into the nitty gritty of things, I will first explain why Java modules were introduced and some issues I have found. Then I will give a brief introduction on <code>Mill</code> and include some pointers to indispensable resources on how to use it. I will then explain how to use <code>Mill</code> to download, compile and execute a OpenJFX application. I will also describe some of Mill's utilities commands to facilitate your work. And finally, I will conclude this presentation with a short summary.</p> 
<h1>Java Module system</h1> 
<p>The Java Platform Module System (JPMS, formerly referred to as <em>Jigsaw</em>) was introduced with JDK 9. The <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">advantages</a> include a means to explicitly define dependencies between libraries so that we can produce smaller and more efficient runtime systems, allow application developers to define service consumers and providers (for example patching at compile time) and restricting access to the internals of a module (Java reflection won't work). Several <a href="https://www.baeldung.com/java-9-modularity">guides</a> and <a href="https://jenkov.com/tutorials/java/modules.html">tutorials</a> exist that can help you get started <sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></sup>.</p> 
<p>When I tried to setup a <code>Scala</code> application to use <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/module-summary.html"><code>java.net.http</code></a>, I had <a href="https://users.scala-lang.org/t/solved-does-dotty-support-javas-jigsaw/6561">problems</a>. I later found that the backward compatibility mode in that specific case works correctly. However, when trying to use the <a href="https://openjfx.io/openjfx-docs/#modular"><code>OpenJFX</code> instructions</a> for the compilation and execution of a <em>"Non-modular application"</em>, I found the following issues:</p> 
<ul> 
 <li>We need to download and install the correct <a href="https://gluonhq.com/products/javafx/">operating system specific versions</a> of the OpenJFX modules;</li> 
 <li>To <a href="http://mail.openjdk.java.net/pipermail/openjfx-dev/2018-June/021977.html"><em>"create a runnable jar with all the required JavaFX dependencies, you will need to use a launcher class that doesn't extend from <code>Application"</code>;</em></a> <sup id="fnref-2"><a class="footnote-ref" href="#fn-2">2</a></sup>;</li> 
 <li>To compile the application we still need to use the <code>--module-path</code> and <code>--add-modules</code> command line arguments for the Java compiler (<code>javac</code>);</li> 
 <li>To package and run the resulting application, we need to package the compiled Java modules and their respective native operating system libraries into a final Jar archive that also contains our application's bytecode.</li> 
</ul> 
<p>Note that the final application may also be operating system independent if all of the required native libraries are downloaded and packaged into the final Jar archive. In this article we will focus on supporting a single operating system.</p> 
<p>The compilation and packaging steps described in the list above can be done manually. However, this is cumbersome, time-consuming and error-prone. A developer would have to first install the <code>OpenJFX</code> modules or download them to a specific directory for a given JDK version. All the compilation and execution commands would then have to be painstakingly changed or parameterized to point to the download directory with these modules. This would pose a significant barrier for someone to quickly clone, use and even contribute to your project.</p> 
<p>In addition to the issues listed above, I have found that several libraries require the use of the module-specific command line arguments for the Java compiler because:</p> 
<ul> 
 <li>Some modules must be opened for access via reflection (for example <a href="https://controlsfx.github.io/">ControlsFX</a> and <a href="https://github.com/GSI-CS-CO/chart-fx">Chart-FX</a>);</li> 
 <li>Some modules must be <em>"patched"</em> to use a specific provider of a given service (for example <a href="https://controlsfx.github.io/">ControlsFX</a> and <a href="https://github.com/TestFX/Monocle"><code>TestFX Monocle</code></a>).</li> 
</ul> 
<p>The <a href="https://openjfx.io/openjfx-docs/#modular"><code>OpenJFX</code> installation instruction</a> however also show that both <a href="https://maven.apache.org/"><code>Maven</code></a> and <a href="https://gradle.org/"><code>Gradle</code></a> can be used to download, compile and package non-modular Java applications. So I set out to replicate part of their functionality in <code>Mill</code> so that you can easily setup your own project that uses JPMS in a non-modular Scala or Java application.</p> 
<h1>Mill</h1> 
<p>When I started my journey learning Scala, the reference build tool was (and <a href="https://docs.scala-lang.org/overviews/scala-book/scala-build-tool-sbt.html">still is</a>) <a href="https://www.scala-sbt.org/">SBT</a>. There are quite a few build tools out their that can be used to build Scala projects (see references [<a href="https://medium.com/@ryanmyles_63493/the-best-build-tools-for-scala-language-dafa39f01936">15</a>, <a href="https://jaxenter.com/build-tools-in-scala-144195.html">18</a>]). In fact, while researching for this article I also found <a href="http://sbuild.org/">SBuild</a>. I, like many other Scala newbies, found SBT somewhat difficult to use due to it peculiar domain specific language (DSL). I also had trouble trying to quickly customize my small projects. The coding, publishing and use of SBT plugins required too much <em>"ceremony"</em>. Of course, this is my opinion and your experience with SBT may not be the same, especially with the improvements that were made since version <code>0.13</code>. The advantages of SBT are: very good documentation and an extensive set of plugins.</p> 
<p>Some time later, I chanced upon a <a href="https://www.youtube.com/watch?v=J0DrSaAqPSY">presentation</a> by <a href="https://github.com/cvogt">Jan Vogt</a> that described the <a href="https://github.com/cvogt/cbt">CBT</a> build tool. I liked the ideas that he presented - a build tool that was <em>simply</em> a Scala library that provided build functionality that could be easily extended and adapted. A build specification was nothing more than a Scala script. That led me to look for build tools with a similar philosophy, and I discovered <a href="https://github.com/com-lihaoyi/mill">Mill</a>. At the time, Mill seemed to be a more promising resource due to its scripting capabilities and the already existing documentation. I decided to investigate it and to date am satisfied with this tool.</p> 
<h2>Brief history and background</h2> 
<p>The tool was originally designed, developed and used by <a href="https://www.lihaoyi.com/">Li Haoyi</a> (<a href="https://github.com/lihaoyi">Li Haoyi GitHub's page</a>). He has developed several other useful open source projects and is well regarded within the Scala community. I would say that currently, circa 2022, the principal maintainer and contributor is <a href="https://github.com/lefou">Tobias Roeser</a>. This is not surprising, since he has also worked on <a href="http://sbuild.org/">Sbuild</a>. Besides other work, he has also additional Mill related projects such as <a href="https://github.com/lefou/millw">MillW</a> and <a href="https://github.com/lefou/mill-integrationtest">Mill-IntegrationTest</a>. The former, I find useful because it allows Windows users to use Mill without prior installation (as is the case with Linux) and, in several occasions, allowed the use of snapshot versions that the <em>original</em> Mill script failed to do. The latter is an "integration test plugin for Mill plugins" which allows anyone contemplating reusing and distributing their Mill scripts, to test them adequately. I tinkered with this some time ago to see how it works.</p> 
<p>There are enough tutorials and documentation to get you up and running in no time. You can find an <a href="https://www.lihaoyi.com/post/MillBetterScalaBuilds.html">early introductory text</a> from Li Haoyi, which is still relevant. He also has video presentations (for example see <a href="https://www.youtube.com/watch?v=j6uThGxx-18">(26)</a>) and a <a href="https://www.handsonscala.com/">book on Scala</a> that describes how to setup and take advantage of the Scala ecosystem (disclaimer - I have not read it). And of course, with Tobias's updates, the <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html">official documentation</a> is an indispensable resource.</p> 
<p>Mill consists of three main components:</p> 
<ul> 
 <li>A Scala scripting] engine (<a href="https://ammonite.io/">Ammonite</a>). This is another of Li Haoyi's <a href="https://github.com/com-lihaoyi/Ammonite">open source project</a>. For a brief introduction on its scripting capabilities see <a href="https://www.baeldung.com/scala/ammonite-scripting">(30)</a>;</li> 
 <li>A dependency resolver and artifact manager. Mill uses <a href="https://get-coursier.io/">Coursier (Pure Scala Artifact Fetching)</a> as its backend. This <a href="https://github.com/coursier/coursier">open source</a> project is a marvel in and of itself that also allows anyone to download, install and execute publicly available Java virtual machine (JVM) based applications and tools (<a href="https://github.com/coursier/setup-action">including</a> Java, Scala and build tools such as SBT);</li> 
 <li>Build utilities that allows one to implement and execute build tasks, define dependencies among tasks and automatically cache and execute those tasks when strictly necessary. This is Mill's core per se and is provided as a set of Scala 2 classes that can be extended as required to fit your every need.</li> 
</ul> 
<p>Before we move onto describing Mill and how it is used, it is important to describe what the Ammonite scripting engine can do. Note that Ammonite also provides an interactive (Read Evaluate and Print Loop) REPL, but we solely focus on its scripting capabilities. In essence Ammonite allows you to code and execute Scala 2 applications as if you are executing a REPL. All you need to do is install Ammonite (<code>amm</code>) and execute the script:</p> 
<pre><code class="language-shell">$ amm MyScript.sc
</code></pre> 
<p>Ammonite will compile and execute that code for you. As with the standard Scala installation, Ammonite also allows you to import from the Scala standard library and use those classes and object you need. Here is an example copied verbatim from <a href="https://ammonite.io/#ScriptFiles">Ammonite's documentation</a>:</p> 
<pre><code class="language-scala">// MyScript.sc
// print banner
println("Hello World!!")

// common imports
import sys.process._
import collection.mutable

// common initialization code
val x = 123
println("x is " + 123)
</code></pre> 
<p>And here is the output:</p> 
<blockquote> 
 <pre><code>Hello World!!
x is 123
</code></pre> 
</blockquote> 
<p>What is even more interesting is that we are not limited do the Scala standard library. We can use <a href="https://ammonite.io/#MagicImports">magic import</a> instructions to <a href="https://ammonite.io/#ScriptImports">import</a>:</p> 
<ul> 
 <li>Other <a href="https://ammonite.io/#OtherScripts">Ammonite script files</a> (<a href="https://ammonite.io/#import$file"><code>import$file</code></a>);</li> 
 <li>Any publicly available <a href="https://ammonite.io/#IvyDependencies">artifacts</a> from Maven or <a href="https://ant.apache.org/ivy/history/latest-milestone/concept.html">Ivy</a> repositories (<a href="https://ammonite.io/#import$ivy"><code>import$ivy</code></a>).</li> 
</ul> 
<p>Ammonite will take care of downloading, caching, compiling and executing your script. You can organize the various script to any depth and complexity you require. Ammonite provides many other goodies we will not take advantage of, which include for example:</p> 
<ul> 
 <li>Staging the imports during script runtime, so you only download what is needed;</li> 
 <li>Having and using multiple entry point (main function);</li> 
 <li>Defining and using command line arguments defined as main function parameters (automatically parsed and converted);</li> 
 <li>Documenting the entry point parameters that are automatically shown in the usage message.</li> 
</ul> 
<p>In essence, the Mill entry point is an Ammonite script named <code>build.sc</code>. You can use all of the above capabilities to your advantage. In addition to this, Mill provides <a href="https://com-lihaoyi.github.io/mill/mill/External_References.html">bundled</a> and libraries that will allow you to quickly and easily set up your Java and Scala projects.</p> 
<h1>Basic Scala build</h1> 
<p>I now describe how Mill is used to set up the <a href="https://github.com/hmf/javaFXMill">example javaFXMill project</a>. For those of you that are new to Mill, I will provide ample information for you to understand and follow along with no problems. You will then be able to create your own projects using this script as a template and use the Mill command line to build and execute your project. Note that you can start your own project with a giter8 template using, for example, the <a href="https://github.com/scalameta/mill-scala-seed.g8">Mill Scala Seed</a> project. For those that usually work with SBT, be warned that the directory structure is not the same. However, Mill does provide a <a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_sbt_compatible_modules">compatibility module</a>, if you wish to maintain that structure.</p> 
<p>The javaFXMill project root contains both the <code>mill</code> binary and the <code>build.sc</code> script. All build paths are relative to this build script. I have also provided a <code>.mill-version</code> configuration file that indicates the version of Mill to be used. The first time you run <code>mill</code> it will check if the correct version of the Mill binary is available. If not, it first downloads the correct version and then delegates to this version the desired command. To check the version you can execute:</p> 
<pre><code class="language-shell">$ ./mill --version
</code></pre> 
<p>And you should get an output similar to this:</p> 
<blockquote> 
 <pre><code class="language-shell">Mill Build Tool version 0.10.2
Java version: 11.0.14.1, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64
Default locale: en_US, platform encoding: UTF-8
OS name: "Linux", version: 5.13.0-39-generic, arch: amd64
</code></pre> 
</blockquote> 
<p>At the start of the <code>build.sc</code> script we have the required imports:</p> 
<pre><code class="language-scala">import mill._
import mill.api.Loose
import mill.define.{Target, Task}
import scalalib._
import coursier.core.Resolution
import java.io.File
</code></pre> 
<p>We are only using Mill's bundled libraries, so no need to use Ammonite's Ivy magic import command. Note that the Coursier API is also available to use if required.</p> 
<p>The project consist of the following 3 modules:</p> 
<ul> 
 <li><code>javafx</code>: an example of compiling and running a <strong>Java</strong> based OpenJFX application using automated dependency management;</li> 
 <li><code>manage</code>: an example of compiling and running a <strong>Scala</strong> 2/3 bases OpenJFX application using <strong>automated</strong> dependency management;</li> 
 <li><code>unmanage</code>: an example of compiling and running a <strong>Scala</strong> 2/3 bases OpenJFX application using <strong>manual</strong> dependency management.</li> 
</ul> 
<p>In Mill each module represents a compilation unit that is defined by a core <a href="https://com-lihaoyi.github.io/mill/mill/Modules.html">Mill object</a>. A compilation unit is defined by extending one or more Mill objects in the build script. The name of the script's object is the name of both the compilation unit and the directory of its sources. Each object assumes a <a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html">common layout</a> and provides a set of parameters and commands that can be accessed via the <code>mill</code> command line. Several Mill modules are provided out-of-the-box that support common project types and configurations. These include:</p> 
<ul> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_java_project_with_test_suite"><code>JavaModule</code></a>: standard Java projects;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_compilation_execution_flags"><code>ScalaModule</code></a>: standard Scala projects;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_cross_scala_version_modules"><code>CrossScalaModule</code></a>: Scala projects that target several binary incompatible Scala versions;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_scala_js_modules"><code>ScalaJSModule</code></a>: <a href="https://www.scala-js.org/">ScalaJS</a> that allow you to develop front-end Web applications using Scala;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_scala_native_modules"><code>ScalaNativeModule</code></a>: <a href="https://scala-native.readthedocs.io/en/latest/">Scala native</a> that targets native applications (<em>"compiled ahead-of-time via LLVM"</em>);</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_sbt_compatible_modules"><code>SbtModule</code></a>: supports Scala projects using the SBT layout;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_sbt_compatible_cross_scala_version_modules"><code>CrossSbtModule</code></a>: same as the <code>CrossScalaModule</code> but uses the SBT layout;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_publishing"><code>PublishModule</code></a>: is a module that can be used as a <em>"mixin"</em> to provide commands for publishing the module as a Maven artifact;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_custom_modules">Custom <code>Module</code></a>: allows us for example to organize the modules in a hierarchical fashion;</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Modules.html#_external_modules"><code>ExternalModules</code></a>: Modules which are shared between several builds;</li> 
</ul> 
<p>I urge those new to Mill, to later take a look at its extensive and detailed documentation. It provides additional information and usage examples that include among others:</p> 
<ul> 
 <li>Defining and using common configurations;</li> 
 <li>Defining and using global configurations (for example to publish artifacts);</li> 
 <li>Using Scala compiler plugins;</li> 
 <li>Using the <code>ScalafmtModule</code> to automatically format your code;</li> 
 <li>Defining a default main class;</li> 
 <li>Using <a href="https://com-lihaoyi.github.io/mill/mill/Modules.html#_foreign_modules">foreign Modules</a>, which allow build scripts to load other Mill projects from external folders using Ammonite’s <code>$file</code> magic import.</li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Contrib_Plugins.html">Contributing</a> to and <a href="https://com-lihaoyi.github.io/mill/mill/Thirdparty_Plugins.html">using</a> third party plugins;</li> 
</ul> 
<p>All of Mill's modules have a common set of variables and methods that represent for example JVM compilation flags, JVM fork flags, environment variables and Mill compilation and execution <a href="https://com-lihaoyi.github.io/mill/mill/Tasks.html">tasks</a>. Each Mill module will also have additional variables and methods specific to its functionality. To define a compilation module in the build script, we need only extend the appropriate Mill module objects and override their methods with the functionality we require. So for the <code>managed</code> compilation module we have:</p> 
<pre><code class="language-scala">val ScalaVersion      = "3.1.1"
val javaFXVersion     = "16"
val mUnitVersion      = "1.0.0-M3"
val controlsFXVersion = "11.1.0"


object managed extends OpenJFX with ScalaModule {
  override def scalaVersion = T{ ScalaVersion }

  override def mainClass: T[Option[String]] = Some("helloworld.HelloWorld")
  override def ivyDeps = Agg(
                              ivy"$CONTROLS",
                              ivy"$CONTROLSFX"
                             )

    object test extends Tests {
      def ivyDeps = Agg(ivyMunit)
      def testFramework = ivyMunitInterface
    }
}
</code></pre> 
<p>It's that simple. Let's review the details. First and foremost the <code>managed</code> compilation unit extends the <code>ScalaModule</code> because we want to generate a Scala application. Next we override the <code>scalaVersion</code> task to indicate that we want to use Scala version 3.1.1. Mill will, via Coursier, make sure the correct Scala compiler is available. Next, we set the default main class that Mill will execute with the <code>run</code> utility command (described in the next section). If only one class or object of the source code has a main method, this configuration is not required because it will use that single main method. However, this compilation unit, has two such methods. So we set the configuration <code>mainClass</code> task to the desired application's main class - <code>helloworld.HelloWorld</code>.</p> 
<p>Usually we need to import and use libraries. Mill uses <a href="https://get-coursier.io/">Coursier</a> to manage these libraries. The <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_adding_ivy_dependencies"><code>ivyDeps</code></a> method allows us to list the Maven artifacts that need to be downloaded and automatically included in both the compilation and execution class paths. These artifacts are cached using <a href="https://ant.apache.org/ivy/">the Ivy dependency manager</a> to avoid repeated downloads. Note that the local user's cache is accessible to any other build tools that use the Ivy or Maven tools. Mill also provides the <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_runtime_and_compile_time_dependencies"><code>runIvyDeps</code> and <code>compileIvyDeps</code></a> configuration tasks that allow one to override and add libraries specifically to either the compilation or execution phases. For example <code>compileIvyDeps</code> will not appear in the transitive dependencies used to construct the compiled class path. Mill also allows you to <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_repository_configuration">configure the repositories</a> used by Coursier to download the artifacts.</p> 
<p>The libraries are defined using Mill's <code>ivy</code> string interpolation operator. The strings used by the <code>manage</code> compilation unit are defined in the <code>OpenJFX</code> module, which extends a <code>JavaModule</code>. We won't go into the details just yet, but suffice to say we simply inherit and use these values as shown above. Below is an excerpt of the <code>OpenJFX</code> module that holds the <code>String</code> names of the libraries. The naming convention is similar to the <a href="https://maven.apache.org/guides/mini/guide-naming-conventions.html">standard convention used by Apache Maven</a> with slight modifications to support explicit versioning and selector usage. The separator <code>:</code> is used for Java, <code>::</code> is used for Scala and <code>:::</code> is used for cross publishing against full Scala versions. The test libraries can be selected by adding <code>;classifier=tests</code> to the end of the library name.</p> 
<pre><code class="language-scala">trait OpenJFX extends JavaModule {

  // Modules 

  val BASE_       = s"base"
  val CONTROLS_   = s"controls"
  val FXML_       = s"fxml"
  val GRAPHICS_   = s"graphics"
  val MEDIA_      = s"media"
  val SWING_      = s"swing"
  val WEB_        = s"web"
  val CONTROLSFX_ = s"controlsfx"

  // Extra modules
  // Note that the module name and the library name are not the same
  val controlsFXModule = "org.controlsfx.controls"

  // Module libraries 
  val BASE       = s"org.openjfx:javafx-$BASE_:$javaFXVersion"
  val CONTROLS   = s"org.openjfx:javafx-$CONTROLS_:$javaFXVersion"
  val FXML       = s"org.openjfx:javafx-$FXML_:$javaFXVersion"
  val GRAPHICS   = s"org.openjfx:javafx-$GRAPHICS_:$javaFXVersion"
  val MEDIA      = s"org.openjfx:javafx-$MEDIA_:$javaFXVersion"
  val SWING      = s"org.openjfx:javafx-$SWING_:$javaFXVersion"
  val WEB        = s"org.openjfx:javafx-$WEB_:$javaFXVersion"
  val CONTROLSFX = s"org.controlsfx:$CONTROLSFX_:$controlsFXVersion"

  val ivyMunit = ivy"org.scalameta::munit::$mUnitVersion"
  val ivyMunitInterface = "munit.Framework"
...
}
</code></pre> 
<p>We defined an additional compilation unit <code>test</code> within the <code>managed</code> module. The <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_adding_a_test_suite"><code>Tests</code> module</a> provides specialized functionality required to automate the execution of unit test. The <code>test</code> module inherits the configuration from its outer module. In particular all of the Ivy artifact dependencies in the <code>managed</code> module are also added automatically to the <code>test</code> module. However, we still need to add the configuration related to the unit test library. The script above imports the <a href="https://scalameta.org/munit/">MUnit</a> library using the following line:</p> 
<pre><code class="language-scala">      def ivyDeps = Agg(ivyMunit)
</code></pre> 
<p>In addition to the library, Mill requires an interface between it and the testing framework. This is the interface that allows it to search for tests, execute them and collect the result to display to the user. The following script's line adds the appropriate interface required by the MUnit library:</p> 
<pre><code class="language-scala">      def testFramework = ivyMunitInterface
</code></pre> 
<p>Each test library has its own interface. It is therefore necessary to know the name of that interface. In case of MUnit it is <code>"munit.Framework"</code>. To make things easier, Mill already provides a set of <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_adding_a_test_suite">predefined test frameworks</a> that you need only inherit from. So the script code for the <code>test</code> module could be defined as :</p> 
<pre><code class="language-scala">    object test extends Tests with TestModule.Munit {
      def ivyDeps = Agg(ivyMunit)
    }
</code></pre> 
<p>The <a href="https://github.com/hmf/javaFXMill">source code</a>, as per the layout rules, is the following:</p> 
<pre><code>├── build.sc
├── javafx
│&nbsp;&nbsp; └── src
│&nbsp;&nbsp;     ├── button
│&nbsp;&nbsp;     │&nbsp;&nbsp; ├── ButtonApp.java
│&nbsp;&nbsp;     │&nbsp;&nbsp; └── Main.java
│&nbsp;&nbsp;     └── helloworld
│&nbsp;&nbsp;         └── HelloWorld.java
├── managed
│&nbsp;&nbsp; ├── src
│&nbsp;&nbsp; │&nbsp;&nbsp; ├── button
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ButtonApp.scala
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── Main.scala
│&nbsp;&nbsp; │&nbsp;&nbsp; └── helloworld
│&nbsp;&nbsp; │&nbsp;&nbsp;     └── HelloWorld.scala
│&nbsp;&nbsp; └── test
│&nbsp;&nbsp;     └── src
│&nbsp;&nbsp;         └── ExampleSpec.scala
├── mill
├── millw
├── millw.bat
├── out
│&nbsp;&nbsp; ├── ...
│&nbsp;&nbsp; ...
├── README.md
└── unmanaged
    ├── src
    │&nbsp;&nbsp; ├── button
    │&nbsp;&nbsp; │&nbsp;&nbsp; ├── ButtonApp.scala
    │&nbsp;&nbsp; │&nbsp;&nbsp; └── Main.scala
    │&nbsp;&nbsp; └── helloworld
    │&nbsp;&nbsp;     └── HelloWorld.scala
    └── test
        └── src
            └── ExampleSpec.scala

</code></pre> 
<p>For each top level compilation unit, we have a corresponding directory at the root of the project. The name of these directories is the same as the module's name. For the inner <code>test</code> modules, these also appear under their parent modules' directories. The structure within the inner modules is the same. You are free to create structures with as many levels as required. I should point out that the outer modules need not contain source code. You can create <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_custom_modules">hierarchical structures</a> simply as a means to organize your code.</p> 
<p>Scala is a <a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">JVM language</a> that provides full interoperability with Java. This means that not only do you have access to Java's ecosystem of libraries, but you can also add your own Java source code to your projects. You need only place the Java source were you place the Scala code. The Scala compiler takes care of the rest. I usually place the Java code in separate packages, but only to ease maintenance and coding. Scala also provides <a href="https://docs.scala-lang.org/overviews/collections/conversions-between-java-and-scala-collections.html">collection conversion libraries</a> to facilitate the use of Java's collections and <a href="https://www.scala-lang.org/api/2.13.8/scala/jdk/javaapi/CollectionConverters$.html">visa versa</a>. Note that the <a href="https://dotty.epfl.ch/api/scala/collection/JavaConverters$.html">older converters</a> are deprecated, and new <a href="https://dotty.epfl.ch/api/scala/jdk/CollectionConverters$.html">Scala 3 versions</a> of the packages are available. Scala 3's <a href="https://docs.scala-lang.org/scala3/book/interacting-with-java.html">introductory text</a> has additional details on interoperability. There are some <a href="https://github.com/travisbrown/scala-java-interop">issues</a> that you need to be aware of, but these can be <a href="https://github.com/sullis/java-scala-interop-examples">dealt with easily</a>. Here are the Scala imports for the Java collections:</p> 
<pre><code class="language-Scala">import scala.jdk.CollectionConverters.*
import scala.jdk.StreamConverters.*
</code></pre> 
<p>One note to add on this, is that both Java and Scala also supports the use of <a href="https://alvinalexander.com/scala/how-to-define-methods-variable-arguments-varargs-fields/">variable length arguments</a>. To use these variable argument Scala methods from Java, you need to <a href="https://alvinalexander.com/scala/how-to-annotate-varargs-methods-in-scala-annotation/">annotate Scala code</a>. When using Java's variable arguments methods from Scala, use Scala's <a href="https://www.baeldung.com/scala/underscore"><code>_*</code></a> operator.</p> 
<h1>Mill Commands and Utilities</h1> 
<h2>Resolve</h2> 
<p>Lets execute the Mill commands for this compilation unit. We start off with the <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_resolve"><code>resolve</code></a> <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_command_line_tools">utility command</a> that lists all the targets (tasks) that are available:</p> 
<pre><code class="language-shell">$ ./mill resolve _
</code></pre> 
<p>The command above produces the following result:</p> 
<blockquote> 
 <pre><code class="language-shell">Compiling /home/user/VSCodeProjects/javaFXMill/build.sc
[1/1] resolve 
all
clean
inspect
javafx
managed
par
path
plan
resolve
show
showNamed
shutdown
shutdown
unmanaged
version
version
visualize
visualizePlan
</code></pre> 
</blockquote> 
<p>We obtain a list of Mill utilities that are always available irrespective of the compilation units we define. These include for example <code>version</code>, <code>clean</code>, <code>resolve</code> and <code>show</code>. We also see listed our compilation units <code>javafx</code>, <code>managed</code> and <code>unmanaged</code> that represent our top level targets. In this case, they are JavaFX applications, but they could, for example, be shared code or libraries. Note that the underscore used in the <code>resolve</code> above is a wildcard. If we used a double underscore <code>__</code> the listing would be recursive. If you have cloned the example repository, give it a try.</p> 
<p>Each object or method we define in the script makes available a number of targets or tasks to the Mill command line. Some of these tasks are inherited from Mill's module objects that we extend as is or override. We are also free to define and use new tasks in the build script. We can also extend several Mill modules as mixins when they provide very specific tasks such as for <a href="https://com-lihaoyi.github.io/mill/mill/Common_Project_Layouts.html#_publishing">publishing artifacts</a> (<code>PublishModule</code>) and executing <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_adding_a_test_suite">unit tests</a> (<code>Tests</code>). So lets take a look at what tasks are available in the <code>managed</code> module by executing the following example:</p> 
<pre><code class="language-shell">$ ./mill resolve managed._
</code></pre> 
<details close> 
 <p><br></p> <summary>And here is the output of the `resolve` command:</summary> 
 <blockquote> 
  <pre><code class="language-shell">[1/1] resolve 
managed.allIvyDeps
managed.allScalacOptions
managed.allSourceFiles
managed.allSources
managed.ammoniteReplClasspath
managed.ammoniteVersion
managed.artifactId
managed.artifactName
managed.artifactScalaVersion
managed.artifactSuffix
managed.assembly
managed.compile
managed.compileClasspath
managed.compileIvyDeps
managed.console
managed.crossFullScalaVersion
managed.docJar
managed.docResources
managed.docSources
managed.finalMainClass
managed.finalMainClassOpt
managed.forkArgs
managed.forkEnv
managed.forkWorkingDir
managed.generatedSources
managed.ideaCompileOutput
managed.ideaConfigFiles
managed.ideaJavaModuleFacets
managed.ivyDeps
managed.ivyDepsTree
managed.jar
managed.javacOptions
managed.javadocOptions
managed.launcher
managed.localClasspath
managed.mainClass
managed.mandatoryIvyDeps
managed.mandatoryScalacOptions
managed.manifest
managed.platformSuffix
managed.prepareOffline
managed.prependShellScript
managed.repl
managed.resolvedAmmoniteReplIvyDeps
managed.resolvedIvyDeps
managed.resolvedRunIvyDeps
managed.resources
managed.run
managed.runBackground
managed.runClasspath
managed.runIvyDeps
managed.runLocal
managed.runMain
managed.runMainBackground
managed.runMainLocal
managed.runUseArgsFile
managed.scalaCompilerClasspath
managed.scalaDocClasspath
managed.scalaDocOptions
managed.scalaDocPluginClasspath
managed.scalaDocPluginIvyDeps
managed.scalaLibraryIvyDeps
managed.scalaOrganization
managed.scalaVersion
managed.scalacOptions
managed.scalacPluginClasspath
managed.scalacPluginIvyDeps
managed.showModuleDeps
managed.sourceJar
managed.sources
managed.test
managed.transitiveCompileIvyDeps
managed.transitiveIvyDeps
managed.transitiveLocalClasspath
managed.unmanagedClasspath
managed.upstreamAssembly
managed.upstreamAssemblyClasspath
managed.upstreamCompileOutput
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<h2>Run and test</h2> 
<p>Each of the <code>managed</code> module's tasks listed above can be executed via the Mill command. These tasks have dependencies among each other and form an execution graph. For example to run the modules main class (<code>managed.run</code>), the target <code>managed.compile</code> must be up-to-date. This means that the <code>managed.compile</code> task will always be executed before the task <code>managed.run</code>, if it is not up-to-date. Mill uses caching extensively to avoid repeating tasks needlessly. Lets see what happens when we issue the command to execute the <code>managed</code> module's main class:</p> 
<pre><code class="language-shell">$ ./mill managed.run
</code></pre> 
<p>The output, after pressing the GUI button thrice is:</p> 
<blockquote> 
 <pre><code class="language-shell">[32/45] managed.compile 
[info] compiling 3 Scala sources to /home/user/VSCodeProjects/javaFXMill/out/managed/compile.dest/classes ...
[info] done compiling
[45/45] managed.run 
Hello Managed Scala World!
Hello Managed Scala World!
Hello Managed Scala World!
</code></pre> 
</blockquote> 
<p>and the following JavaFX (OpenJFX) GUI should appear:</p> 
<p><img src="http://www.jbake.org/blog/2020/mill/javafx/managed_run_screenshot.png#center" alt="GUI from managed.run"></p> 
<p>Mill, by default, executes the application by forking a new JVM. However, one can also execute the application in Mill's JVM with the following command:</p> 
<pre><code class="language-shell">$ ./mill managed.runLocal
</code></pre> 
<p>and the results should be the same.</p> 
<p>We can also select the particular <code>main</code> method to execute. To do this we need only use the <code>runMain</code> target. The example code has two JavaFX applications. To execute either of these applications use one of these commands:</p> 
<pre><code class="language-shell">$ ./mill -i managed.runMain helloworld.HelloWorld
$ ./mill -i managed.runMain button.Main
</code></pre> 
<p>The first command above produces the same result as described for the <code>run</code> target - the default main class is <code>helloworld.HelloWorld</code>. The <code>button.Main</code> application opens this dialogue box:</p> 
<p><img src="http://www.jbake.org/blog/2020/mill/javafx/managed_runmain_screenshot.png#center" alt="Managed runMain Screenshot"></p> 
<p>To test the code, we must select the unit test framework to use, prepare those unit tests and then execute them. We have already seen how to setup the <a href="https://scalameta.org/munit/">MUnit</a> framework. Here we show how to execute these tests via the Mill Command line. We won't go into any detail here. The goal is to have the example serve as a template for your future work. The <code>manage</code> module has the test source code placed in its inner <code>test</code> module. I have provided a single test example in the following directory:</p> 
<pre><code>managed/test/src/ExampleSpec.scala
</code></pre> 
<p>and here is the sample test:</p> 
<pre><code class="language-scala">class ExampleSpec extends munit.FunSuite {

  test("test_ok") {
    val obtained = 42
    val expected = 42
    assertEquals(obtained, expected)
  }

  test("test_fails") {
    val obtained = 42
    val expected = 43
    assertEquals(obtained, expected)
  }
}
</code></pre> 
<p>I have made sure the test will fail so that you can see how easily one can track the failed test to the test's source code. To execute all of the tests under <code>managed</code> compilation unit execute:</p> 
<pre><code class="language-shell">$ ./mill -i managed.test
</code></pre> 
<p>This produces the following result:</p> 
<blockquote> 
 <pre><code>[60/70] managed.test.compile 
[info] compiling 1 Scala source to /home/user/VSCodeProjects/javaFXMill/out/managed/test/compile.dest/classes ...
[info] done compiling
[70/70] managed.test.test 
managed.ExampleSpec:
  + test_ok 0.008s
==&gt; X managed.ExampleSpec.test_fails  0.02s munit.ComparisonFailException: /home/user/VSCodeProjects/javaFXMill/managed/test/src/ExampleSpec.scala:32
31:    val expected = 43
32:    assertEquals(obtained, expected)
33:  }
values are not the same
=&gt; Obtained
42
=&gt; Diff (- obtained, + expected)
-42
+43
    at munit.FunSuite.assertEquals(FunSuite.scala:11)
    at managed.ExampleSpec.$init$$$anonfun$2(ExampleSpec.scala:32)
1 targets failed
managed.test.test 1 tests failed: 
  managed.ExampleSpec.test_fails managed.ExampleSpec.test_fails
</code></pre> 
</blockquote> 
<p>Mill searches for all tests and executes these MUnit tests. For each unit test suite that is found, MUnit will print out the test suite's name as follows:</p> 
<blockquote> 
 <p>
  <g>
   managed.ExampleSpec:
  </g></p> 
</blockquote> 
<p>For each test in the test suite, the test name is shown in green if it passes:</p> 
<blockquote> 
 <p>
  <g>
   managed.ExampleSpec:
   <g>
    <br> 
    <g>
      + test_ok 0.008s
     <g></g>
    </g>
   </g>
  </g></p> 
</blockquote> 
<p>However, if it fails, the test name is shown in red together with the highlighted source code location of the failed test:</p> 
<blockquote> 
 <p>
  <r>
   =&gt; X managed.ExampleSpec.test_fails
  </r> <gr>
   0.02s
  </gr> munit.ComparisonFailException: /home/user/VSCodeProjects/javaFXMill/managed/test/src/ExampleSpec.scala:32<br> 31: val expected = 43<br> <bw>
   <gr>
    32: assertEquals(obtained, expected)
   </gr>
  </bw><br> 33: }</p> 
</blockquote> 
<p>And when possible, the values used for the test are also shown:</p> 
<blockquote> 
 <p>values are not the same<br> <strong>=&gt; Obtained</strong><br> 42<br> <strong>=&gt; Diff</strong> (<r>
   - obtained
  </r>, <g>
   + expected
  </g>)<br> <r>
   -42
  </r><br> <g>
   +43
  </g><br></p> 
</blockquote> 
<p>Mill, by default, executes your applications and tests, by forking a new JVM. You can also execute them within the same JVM as Mill:</p> 
<pre><code class="language-shell">$ ./mill -i managed.test.testLocal
</code></pre> 
<p>and the results should be the same.</p> 
<p>We can use as many test suites as we wish. However, repeatedly executing all the tests may take too much time. We can use the following command to select a single test suite. This command executes all of the tests in the <code>managed.ExampleSpec</code> test suite:</p> 
<pre><code class="language-shell">$ ./mill -i managed.test managed.ExampleSpec.*
</code></pre> 
<p>The results will be the same as above. It is important to add the wildcard <code>*</code> otherwise no tests are executed (a <code>**</code> will also work). Mill will only list the tests that were identified and executed. It will silently fail if no tests were found, for example if you use an incorrect name.</p> 
<p>We can also select a single test:</p> 
<pre><code class="language-shell">$ ./mill -i managed.test managed.ExampleSpec.test_ok
</code></pre> 
<p>or multiple tests using partial matching. The commands below are equivalent:</p> 
<pre><code class="language-shell">$ ./mill -i managed.test "managed.ExampleSpec.test_*"
$ ./mill -i managed.test managed.ExampleSpec.test_*
</code></pre> 
<p>I have yet to find a way to execute named tests separately. For example, the following line will incorrectly execute all the tests when none should be executed:</p> 
<pre><code class="language-shell">$ ./mill -i "managed.test managed.ExampleSpec.test_okX" + "managed.test managed.ExampleSpec.test_fail"
</code></pre> 
<p>In fact all tests are executed if we use quotes on the test target (even if we indicate a non-existent test):</p> 
<pre><code class="language-shell">$ ./mill -i "managed.test managed.ExampleSpec.test_fail"
</code></pre> 
<p>which seems like an error.</p> 
<h2>Show and inspect</h2> 
<p>Mill's <code>run</code> command will automatically look for a class or object with a main method and execute it, passing it any arguments you place on the command line. If you analyse the example code, you will see that the module has two main classes:</p> 
<ul> 
 <li><code>button.Main</code></li> 
 <li><code>helloWorld.HelloWorld</code></li> 
</ul> 
<p>In these circumstances if the <code>ScalaModule</code> <code>mainClass</code> member is not overridden, then the following command:</p> 
<pre><code class="language-shell">$ ./mill managed.run
</code></pre> 
<p>will result in an error such as this:</p> 
<blockquote> 
 <pre><code class="language-shell">Compiling /home/user/VSCodeProjects/javaFXMill/build.sc
[34/45] managed.finalMainClass 
1 targets failed
managed.finalMainClass Multiple main classes found (button.Main,helloworld.HelloWorld) please explicitly specify which one to use by overriding mainClass
</code></pre> 
</blockquote> 
<p>I have been using the words <em>"target"</em> and <em>"task"</em> interchangeably, but not all tasks are target tasks. The <a href="https://com-lihaoyi.github.io/mill/mill/Tasks.html">official documentation</a> contains details on the type of tasks and their various properties. Task types include targets, sources and commands. These tasks properties indicate, for example, whether they are runnable from command line, if their results are cached or if they can take arguments.</p> 
<p>Metadata is associated with each task. This includes configuration data that is either set by us in the build script, set by defaults, set by the Mill modules or generated during task execution (for example used for caching). This metadata is stored in JSON format and placed in a hidden <code>.out</code> directory in the project's root. The structure of the modules within this output directory are the same as those defined in the script file. So, after executing the <code>managed</code> commands above we can list the contents of this directory:</p> 
<pre><code class="language-shell">$ ls -1 ./out/
</code></pre> 
<p>and we can see the metadata of the utility commands and the <code>managed</code> module:</p> 
<blockquote> 
 <pre><code class="language-shell">clean.json
inspect.json
inspect.log
managed
mill
mill-profile.json
mill-worker-laf+3l
show.json
show.log
</code></pre> 
</blockquote> 
<p>And if we look deeper into the <code>managed</code> module:</p> 
<pre><code class="language-shell">$ ls -1 ./out/managed
</code></pre> 
<details close> 
 <p><br></p> <summary>we will see additional metadata related to each of the module's tasks:</summary> 
 <blockquote> 
  <pre><code class="language-shell">allScalacOptions.json
allSourceFiles.json
allSources.json
compileClasspath.json
compile.dest
compileIvyDeps.json
compile.json
compile.log
enablePluginScalacOptions.json
finalMainClassOpt.json
forkArgs.json
forkEnv.json
forkEnv.overridden
forkWorkingDir.json
generatedSources.json
ivyDeps.json
javacOptions.json
localClasspath.json
mainClass.json
mandatoryIvyDeps.json
mandatoryIvyDeps.overridden
mandatoryScalacOptions.json
platformSuffix.json
resolvedIvyDeps.json
resolvedRunIvyDeps.json
resources.json
runClasspath.json
runIvyDeps.json
run.json
run.log
runUseArgsFile.json
scalaCompilerClasspath.json
scalacOptions.json
scalacPluginClasspath.json
scalacPluginIvyDeps.json
scalaLibraryIvyDeps.json
scalaOrganization.json
scalaVersion.json
sources.json
transitiveCompileIvyDeps.json
transitiveIvyDeps.json
transitiveLocalClasspath.json
unmanagedClasspath.json
upstreamAssemblyClasspath.json
upstreamCompileOutput.json
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>We could look into those metadata files to learn more about the compiled build script and debug it. However, Mill provides an easier way to query your build scripts. In many cases we want to print out a value of a configuration task. To do this, we use the <code>show</code> utility command. For example, we can query the <code>managed</code> compilation module to find out what the main class is:</p> 
<pre><code class="language-shell">$ ./mill show managed.mainClass
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code class="language-json">[
  "helloworld.HelloWorld"
]
</code></pre> 
</blockquote> 
<p>or determine what the Scala version was set to:</p> 
<pre><code class="language-shell">$ ./mill show managed.scalaVersion
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code class="language-shell">[1/1] show 
"3.1.1"
</code></pre> 
</blockquote> 
<p>The <code>show</code> command is very useful, for example, when debugging your class path. In particular, it allows us to see what Mill is doing <em>"under the hood"</em>. Some tasks related to class paths include:</p> 
<pre><code class="language-shell">$ ./mill resolve managed._ | grep -i path
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code class="language-shell">[1/1] resolve 
managed.ammoniteReplClasspath
managed.compileClasspath
managed.localClasspath
managed.runClasspath
managed.scalaCompilerClasspath
managed.scalaDocClasspath
managed.scalaDocPluginClasspath
managed.scalacPluginClasspath
managed.transitiveLocalClasspath
managed.unmanagedClasspath
managed.upstreamAssemblyClasspath
</code></pre> 
</blockquote> 
<p>For example, we can see what the compile-time class path is, by executing the following command:</p> 
<pre><code class="language-shell">$ ./mill show managed.compileClasspath
</code></pre> 
<details close> 
 <p><br></p> <summary>Output:</summary> 
 <blockquote> 
  <pre><code class="language-shell">[1/1] show 
[1/1] show &gt; [15/15] managed.compileClasspath 
[
  "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/managed/resources",
  "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
  "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar",
  "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>Note that the <code>managed</code> module uses Mill's managed class path functionality. That means all Maven dependencies are automatically pulled in. In addition to this, it also identifies the current operating system and only downloads the required native libraries. The list above shows several libraries that we did not explicitly include in the <code>ivyDeps</code> configuration task, including the Scala core libraries. If you execute the <code>./mill show managed.runClasspath</code>, you will also see that it is the same as the <code>compileClasspath</code> configuration. As I have pointed out you can use the <code>runIvyDeps</code> and <code>compileIvyDeps</code> configuration tasks to set up different libraries for the compilation and runtime phases.</p> 
<p>To explore the transitive libraries' setup by Mill, the following tasks can be used:</p> 
<pre><code class="language-shell">$ ./mill resolve managed._ | grep -i transitive
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code class="language-shell">[1/1] resolve 
managed.transitiveCompileIvyDeps
managed.transitiveIvyDeps
managed.transitiveLocalClasspath
</code></pre> 
</blockquote> 
<p>In particular, <code>transitiveCompileIvyDeps</code> is of interest because it indicates which libraries are managed. It also provides additional information, such as the publication classifiers used and the cross-compilation or operating system platform tags that are set. Later we will see how we can manually set up libraries that won't be managed by Mill.</p> 
<p>The <code>test</code> compilation unit we define within the <code>managed</code> compilation unit inherits the setup from this outer object. This means that the dependencies declared in the <code>managed</code> module will also be ued in the inner module. The <code>test</code> module uses the <a href="https://scalameta.org/munit/">MUnit</a> framework to execute the unit tests, so this library is only required by the <code>test</code> compilation unit. To confirm this, execute the following command to list its managed libraries:</p> 
<pre><code class="language-shell">$ ./mill show managed.test.compileClasspath
</code></pre> 
<details close> 
 <p><br></p> <summary>Output:</summary> 
 <blockquote> 
  <pre><code class="language-shell">[1/1] show 
[1/1] show &gt; [47/47] managed.test.compileClasspath 
[
  "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/managed/resources",
  "ref:cd75580a:/home/user/VSCodeProjects/javaFXMill/out/managed/compile.dest/classes",
  "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/managed/test/resources",
  "qref:45efcd0d:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/munit_3/1.0.0-M3/munit_3-1.0.0-M3.jar",
  "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
  "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "qref:0440c0f1:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/junit-interface/1.0.0-M3/junit-interface-1.0.0-M3.jar",
  "qref:26e95212:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar",
  "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar",
  "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "qref:9e7bca5a:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar",
  "qref:6f3db795:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar",
  "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>The above list shows the MUnit library and its dependencies. These libraries do not appear in the <code>managed</code> compilation unit, but are available in the <code>test</code> compilation unit.</p> 
<p>The <code>show</code> command can also be used to print out the metadata of more than one task. For example the following command can be used to show the metadata of the <code>sources</code> and <code>compileClasspath</code> tasks.</p> 
<pre><code class="language-shell">$ ./mill show "managed.{sources,compileClasspath}"
</code></pre> 
<details close> 
 <p><br></p> <summary>Output:</summary> 
 <blockquote> 
  <pre><code class="language-shell">[1/1] show 
[1/1] show &gt; [3/16] managed.resources 
[
  [
    "ref:f01978bc:/home/user/VSCodeProjects/javaFXMill/managed/src"
  ],
  [
    "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/managed/resources",
    "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
    "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
    "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
    "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
    "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
    "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar",
    "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
    "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
    "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
  ]
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>The <code>showNamed</code> utility command is the same as the <code>show</code> command, but each of the output elements are now indexed with the task name. This comes in handy when you view more than one task at the same time, as is shown below:</p> 
<pre><code class="language-shell">$ ./mill showNamed "managed.{sources,compileClasspath}"
</code></pre> 
<details close> 
 <p><br></p> <summary>Output:</summary> 
 <blockquote> 
  <pre><code class="language-shell">[1/1] showNamed 
[1/1] showNamed &gt; [3/16] managed.resources 
{
  "managed.sources": [
    "ref:f01978bc:/home/user/VSCodeProjects/javaFXMill/managed/src"
  ],
  "managed.compileClasspath": [
    "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/managed/resources",
    "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
    "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
    "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
    "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
    "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
    "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar",
    "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
    "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
    "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
  ]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>The <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_inspect"><code>inspect</code></a> is a more verbose version of the <code>show</code> command. It is employed in the same way as the <code>show</code> command and also allows for the use of wildcards. Besides the information that <code>show</code> provides, <code>inspect</code> also includes a <a href="https://ammonite.io/#ScriptUsageDocs">description of the tasks</a> and a list of inputs to those tasks. This provides a technique for the fine-grained exploration and debugging of your Mill scripts. Here is an example of the <code>run</code>target:</p> 
<pre><code class="language-shell">$ ./mill inspect managed.run
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code>[1/1] inspect 
managed.run(JavaModule.scala:611)
    Runs this module's code in a subprocess and waits for it to finish

Inputs:
    managed.finalMainClass
    managed.runClasspath
    managed.forkArgs
    managed.forkEnv
    managed.forkWorkingDir
    managed.runUseArgsFile
</code></pre> 
</blockquote> 
<p>Note that surprisingly, we do not see the <code>mainClass</code> target we set in the <code>managed</code> task. But if we probe the <code>finalMainClass</code> further we get:</p> 
<pre><code class="language-shell">$ ./mill inspect managed.finalMainClass
</code></pre> 
<p>Output:</p> 
<blockquote> 
 <pre><code>[1/1] inspect 
managed.finalMainClass(JavaModule.scala:74)

Inputs:
    managed.finalMainClassOpt
</code></pre> 
</blockquote> 
<p>And if we look at the <a href="https://github.com/com-lihaoyi/mill/blob/0.10.2/scalalib/src/JavaModule.scala#L74">Mill source code</a> we find the following code snippet:</p> 
<pre><code class="language-scala">  /**
   * Allows you to specify an explicit main class to use for the `run` command.
   * If none is specified, the classpath is searched for an appropriate main
   * class to use if one exists
   */
  def mainClass: T[Option[String]] = None

  def finalMainClassOpt: T[Either[String, String]] = T {
    mainClass() match {
      case Some(m) =&gt; Right(m)
      case None =&gt;
        zincWorker.worker().discoverMainClasses(compile()) match {
          case Seq() =&gt; Left("No main class specified or found")
          case Seq(main) =&gt; Right(main)
          case mains =&gt;
            Left(
              s"Multiple main classes found (${mains.mkString(",")}) " +
                "please explicitly specify which one to use by overriding mainClass"
            )
        }
    }
  }

  def finalMainClass: T[String] = T {
    finalMainClassOpt() match {
      case Right(main) =&gt; Result.Success(main)
      case Left(msg) =&gt; Result.Failure(msg)
    }
  }
</code></pre> 
<p>Sure enough, the target uses the <code>mainClass</code> task that we override in our build script. Personally, I prefer the use of the <a href="https://www.jetbrains.com/idea/">IntelliJ IDE</a> to debug some of my more complex Mill scripts. This IDE supports the parsing and analysis of Ammonite scripts, so with a simple <code>ctrl+left button mouse click</code> we can explore our script efficiently.</p> 
<h2>Analysing the dependency graph</h2> 
<p>I have already shown Mill commands that you can use to find dependencies between tasks. Recall that Mill tasks form a directed acyclic graph (DAG) that determines which tasks must be executed and the order in which they must be executed. These dependencies are set by Mill internally, either <a href="https://com-lihaoyi.github.io/mill/mill/Tasks.html#_task_graphs">by explicit calls</a> between tasks that we define ourselves or overriding <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_multiple_modules"><code>moduleDeps</code></a>, which sets dependencies between whole compilation units.</p> 
<p>Mill provides the <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_path"><code>path</code></a> task that allows us to explore and check the dependencies between two tasks. The first argument is the final target of the path. The official documentation states that if more than one path exists between two targets, one will be selected arbitrarily. I am assuming that this path is selected deterministically and therefore represents the true execution path of Mill. If we execute the following command:</p> 
<pre><code class="language-shell">$ ./mill path managed.assembly managed.sources
</code></pre> 
<p>we get:</p> 
<blockquote> 
 <pre><code class="language-shell">Compiling /home/user/VSCodeProjects/javaFXMill/build.sc
[1/1] path 
managed.sources
managed.allSources
managed.allSourceFiles
managed.compile
managed.localClasspath
managed.assembly
</code></pre> 
</blockquote> 
<p>You can now use the <code>show</code> and <code>inspect</code> commands to obtain more information on each of the targets listed above. For example, to identify all the source files used to generate the compilation unit's Jar library we can use:</p> 
<pre><code class="language-shell">$ ./mill inspect managed.allSourceFiles
</code></pre> 
<p>to check if that target will provide the intended information. From this output, it seems so:</p> 
<blockquote> 
 <pre><code>[1/1] inspect 
managed.allSourceFiles(ScalaModule.scala:51)
    All individual source files fed into the Zinc compiler.

    All individual source files fed into the Java compiler

Inputs:
    managed.allSources
</code></pre> 
</blockquote> 
<p>To get a list of the actual source files, we use:</p> 
<pre><code class="language-shell">$ ./mill show managed.allSourceFiles
</code></pre> 
<p>and get:</p> 
<blockquote> 
 <pre><code>[1/1] show 
[1/1] show &gt; [4/4] managed.allSourceFiles 
[
  "ref:6db4a3f8:/home/user/VSCodeProjects/javaFXMill/managed/src/helloworld/HelloWorld.scala",
  "ref:2636cdfc:/home/user/VSCodeProjects/javaFXMill/managed/src/button/Main.scala",
  "ref:9e0369bc:/home/user/VSCodeProjects/javaFXMill/managed/src/button/ButtonApp.scala"
]
</code></pre> 
</blockquote> 
<p>and indeed those are all the sources we have in our <code>managed</code> module, which has no other dependencies with any other module. It is important to point out the <code>path</code> command does not show all the targets that will be executed. For example the <code>managed.compile</code> target that compiles all the code, has additional dependencies. If we use the command:</p> 
<pre><code class="language-shell">$ ./mill inspect managed.compile
</code></pre> 
<p>we see in the following output that the <code>managed.allSources</code> target is but one of the inputs of the <code>managed.compile</code>target:</p> 
<blockquote> 
 <pre><code>[1/1] inspect 
managed.compile(ScalaModule.scala:195)
    Compiles the current module to generate compiled classfiles/bytecode.
    
    When you override this, you probably also want to override [[bspCompileClassesPath]].

Inputs:
    managed.scalaVersion
    managed.upstreamCompileOutput
    managed.allSourceFiles
    managed.compileClasspath
    managed.javacOptions
    managed.scalaOrganization
    managed.allScalacOptions
    managed.scalaCompilerClasspath
    managed.scalacPluginClasspath
</code></pre> 
</blockquote> 
<p>Of particular interest is the <code>managed.upstreamAssemblyClasspath</code> target that can show us the dependencies used to compile and run the module. The following command can be used to explore those dependencies:</p> 
<pre><code class="language-shell">$ ./mill inspect managed.upstreamAssemblyClasspath
</code></pre> 
<p>which, allows use to further identify and explore targets of interest that are shown in the command's output below:</p> 
<blockquote> 
 <pre><code>[1/1] inspect 
managed.upstreamAssemblyClasspath(JavaModule.scala:356)
    All upstream classfiles and resources necessary to build and executable
    assembly, but without this module's contribution

Inputs:
    managed.transitiveLocalClasspath
    managed.unmanagedClasspath
    managed.resolvedRunIvyDeps
</code></pre> 
</blockquote> 
<p>For example, we can determine all the third party libraries that are required to compile the <code>managed</code> module using the following command:</p> 
<pre><code>$ ./mill show managed.resolvedRunIvyDeps
</code></pre> 
<details open> <summary>And those libraries are listed in the output below:</summary> 
 <blockquote> 
  <pre><code>[1/1] show 
[1/1] show &gt; [10/10] managed.resolvedRunIvyDeps 
[
  "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "qref:5276bca2:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.2/scala3-library_3-3.1.2.jar",
  "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "qref:815c539d:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.8/scala-library-2.13.8.jar",
  "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
]
</code></pre> 
 </blockquote>
</details> 
<br>  
<p>I suggest that when you define your own tasks, you use Ammonite's <a href="https://ammonite.io/#ScriptUsageDocs">usage doc annotations</a> to provide useful information that will be shown by the <code>inspect</code> command. This will allow users, of your build script, to explore your targets and tasks as if they were standard Mill tasks.</p> 
<p>Usually we don't know, or cannot recall, the names of the targets that are dependencies and what order those dependencies should be. For example, if we use the incorrect order, Mill will complain:</p> 
<blockquote> 
 <pre><code class="language-shell">[1/1] path 
1 targets failed
path No path found between managed.sources and managed.assembly
</code></pre> 
</blockquote> 
<p>The <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_plan"><code>plan</code></a> utility command is useful in that we need only provide the final target. It will determine all the targets and tasks that need to be executed. These are sorted for a dry-run and shown in the order they would have been executed by Mill. The command below can be used to show the (often long) list of tasks that must be executed to produce the desired output of the target:</p> 
<pre><code class="language-shell">$ ./mill plan managed.assembly
</code></pre> 
<details close> <summary>Output:</summary> 
 <br> 
 <blockquote> 
  <pre><code>[1/1] plan 
managed.resources
managed.scalaVersion
mill.scalalib.ZincWorkerModule.classpath
mill.scalalib.ZincWorkerModule.worker
managed.upstreamCompileOutput
managed.sources
managed.generatedSources
managed.allSources
managed.allSourceFiles
managed.transitiveLocalClasspath
managed.unmanagedClasspath
managed.platformSuffix
managed.compileIvyDeps
managed.transitiveCompileIvyDeps
managed.ivyDeps
managed.mandatoryIvyDeps.overridden.mill.scalalib.JavaModule.mandatoryIvyDeps
managed.scalaOrganization
managed.scalaLibraryIvyDeps
managed.mandatoryIvyDeps
managed.transitiveIvyDeps
managed.resolvedIvyDeps
managed.compileClasspath
managed.javacOptions
managed.mandatoryScalacOptions
managed.scalacPluginIvyDeps
managed.enablePluginScalacOptions
managed.scalacOptions
managed.allScalacOptions
managed.scalaCompilerClasspath
managed.scalacPluginClasspath
managed.compile
managed.localClasspath
managed.mainClass
managed.finalMainClassOpt
managed.manifest.overridden.mill.scalalib.JavaModule.manifest
managed.manifest
managed.runIvyDeps
managed.resolvedRunIvyDeps
managed.upstreamAssemblyClasspath
managed.runClasspath
managed.forkArgs
managed.prependShellScript
managed.upstreamAssembly
managed.assembly
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>Note that just because the tasks are listed for the dry-run, does not mean they will actually be executed. If the cached results can be reused, they will serve as input to their dependent tasks. It is also important to point out that not all <a href="https://com-lihaoyi.github.io/mill/mill/Tasks.html#_task_cheat_sheet">Mill task types</a> use caching. In those cases the tasks will always be executed.</p> 
<p>It would also be interesting to see the unordered set of tasks in a tree-like structure. Mill does not seem to have this, but it does have a <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_visualize"><code>visualize</code></a> utility command. This command determines and plots the dependency DAG of a target. This utility command seems to require <a href="https://graphviz.org/">GraphViz</a> to generate the plots, so before proceeding, install it. I suspect GraphViz is used to produce the <code>png</code>and <code>svg</code> plots from the <code>dot</code> source. For my Linux distribution I used these<sup id="fnref-3"><a class="footnote-ref" href="#fn-3">3</a></sup> commands:</p> 
<pre><code class="language-shell">$ sudo apt-get install -y graphviz
$ sudo apt-get install -y graphviz-dev
</code></pre> 
<p>The following instruction:</p> 
<pre><code class="language-shell">$ ./mill show visualize managed._
</code></pre> 
<p>shows what files are generated by the <code>visualize</code> utility command, and it also generates that output:</p> 
<blockquote> 
 <pre><code>[1/1] show 
[1/1] show &gt; [3/3] visualize 
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
[
  "ref:1c1b3ff8:/home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.txt",
  "ref:520f50af:/home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.dot",
  "ref:1cb6580f:/home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.json",
  "ref:bef28556:/home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.png",
  "ref:31845709:/home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.svg"
]
</code></pre> 
</blockquote> 
<p>The <code>visualize</code> command generates both the source description of the DAG (<code>txt</code>, <code>dot</code> and <code>json</code> files) as well as the graphic output of the DAG (<code>png</code> and <code>svg</code> files). You can for example use the following command in the Linux prompt to visualize the DAG:</p> 
<pre><code class="language-shell">$ shotwell /home/user/VSCodeProjects/javaFXMill/out/visualize.dest/out.png
</code></pre> 
<p>The <code>svg</code> output is shown below:</p> 
<p><img src="http://www.jbake.org/blog/2020/mill/javafx/managed_visualize.svg#center" alt="./mill show visualize managed._"></p> 
<p>There is also a similar <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_visualizeplan"><code>visualizePlan</code></a> utility command. Unlike <code>visualize</code>, it shows all targets, irrespective of whether or not they are resolved by the current target query. These non-resolved tasks, which are <strong>not</strong> generated by <code>visualise</code>, are shown with a <strong>dotted</strong> borderlines. The command below:</p> 
<pre><code class="language-shell">$ ./mill show visualizePlan managed._
</code></pre> 
<p>generates a similar output:</p> 
<blockquote> 
 <pre><code>[1/1] show 
[1/1] show &gt; [3/3] visualizePlan 
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
[
  "ref:ea2a153b:/home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.txt",
  "ref:0d064b81:/home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.dot",
  "ref:280e3f4d:/home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.json",
  "ref:c47c7d39:/home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.png",
  "ref:f526ae0b:/home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.svg"
]
</code></pre> 
</blockquote> 
<p>The DAG, shown below, is also very similar but if you look closely, the <em>"dotted"</em> tasks there, do not appear in the previous DAG:</p> 
<p><img src="http://www.jbake.org/blog/2020/mill/javafx/managed_visualize_plan.svg#center" alt="./mill show visualizePlan managed._"></p> 
<p>I wanted to give you a sense of the complexity these DAGs can have. This is a very small project but the DAG is already substantial. For medium size projects with dependencies between modules (see <code>moduleDeps</code> configuration task), the DAGs become very large. So be selective in choosing your query targets.</p> 
<p>You may also find it easier to view the SVG files, which allow zooming and panning without loss of image quality, unlike the raster images such as <a href="https://www.w3.org/TR/PNG/">PNG</a>. Any web browser should allow you to view these files. In addition to this, I also use <a href="https://inkscape.org/">InkScape</a> to view the files and possibly alter them for publishing. On my Linux distribution I used the following commands to install InkScape:</p> 
<pre><code class="language-shell">$ sudo add-apt-repository ppa:inkscape.dev/stable
$ sudo apt update
$ sudo apt install inkscape
</code></pre> 
<p>And to view<sup id="fnref-4"><a class="footnote-ref" href="#fn-4">4</a></sup> the file, I use the following command:</p> 
<pre><code class="language-shell">$ inkscape /home/user/VSCodeProjects/javaFXMill/out/visualizePlan.dest/out.svg &amp;
</code></pre> 
<p>At this point you should be able to:</p> 
<ul> 
 <li>Create your own Scala project</li> 
 <li>Setup a Mill project that uses Maven artifacts</li> 
 <li>Compile and run your code</li> 
 <li>Execute unit tests</li> 
</ul> 
<p>In addition to what I have described, two additional commands (<code>managed.assembly</code> and <code>managed.publish</code>) may be of interest for <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_deploying_your_code">deploying your code</a>. We won't describe these here. The official documentation provides the necessary details. I will just add that by using the <code>publish</code> target and making your artifacts available via Maven, allows a user to easily install one of your applications with Coursier.</p> 
<h2>Using your IDE</h2> 
<p>One way to develop your system is to alter your code and then execute the Mill targets to compile the source code, run the main method or execute the unit tests. However, it is tedious and cumbersome to switch between your editor and the command line. Mill provides us with the <code>--watch</code> flag that can be used, for example, as follows:</p> 
<pre><code class="language-shell">$ ./mill -i --watch managed.compile
$ ./mill -i --watch managed.runMain helloworld.HelloWorld
$ ./mill -i --watch managed.run
$ ./mill -i --watch managed.test
</code></pre> 
<p>This flag ensures that Mill continuously scans the target's sources and if any change is detected, the command is automatically executed again. This means that we can edit, compile and execute our code without leaving the editor. It also has the added advantage of avoiding the wasted time of launching a new JVM for Mill.</p> 
<p>A note on the <code>-i</code> flag. Without this flag, a Mill server is launched in the background. This means that a JVM is kept warm and execution is faster. However, the use of the Mill server does not seem to work perfectly in Windows. It is therefore advisable that, at least in Windows, the <code>interactive</code> flag be used so that no background session be started.</p> 
<p>For those of us that use IDEs, we can still use Mill in a terminal together with the <code>-i</code> and <code>-watch</code> flags. However, native IDE Mill support allows us to take full advantage of all its functionality. <a href="https://www.jetbrains.com/idea/">IntelliJ</a> is one of my favourite IDEs. It currently does not support Mill build files. However, Mill provides the following command to generate native IntelliJ projects:</p> 
<pre><code>$ mill mill.scalalib.GenIdea/idea
</code></pre> 
<p>Once executed, you can load the project. I have found that this works well with Scala 2 projects. For Scala 3, this is not the case (circa April 2022), although with some <a href="https://github.com/com-lihaoyi/mill/discussions/1455">tweaking</a> you may get it to work. I find that Scala 3's <em>"braceless"</em> syntax is not recognized, which makes coding difficult. However, using native IntelliJ projects when created from the IDE itself, does work correctly for Scala 3.</p> 
<p>Note that every time you add or remove dependencies or change your Mill script, you need to rerun the command above. You can then edit and execute your code and even perform your unit tests within the IDE. IntelliJ also has the advantage that it allows you to code and analyze Ammonite scripts. This is a boon when you are debugging more complex scripts. It also allows you to explore the Mill projects scripts with a simple <code>ctrl+left button click</code> on the script's methods and values. Remember that you will need to reload the Mill scripts after every change, as I have already explained. The Mill targets and your custom tasks will not be accessible through the IDE, but you are free to use it simultaneously in another terminal.</p> 
<p>Note that <a href="https://scalacenter.github.io/bloop/docs/ides/intellij">IntelliJ also supports</a> <a href="https://scalacenter.github.io/bloop/">Bloop</a>. However, Mill is <a href="https://scalacenter.github.io/bloop/docs/ides/intellij">not automatically supported</a>. Integration via Bloop is made available with a <a href="https://com-lihaoyi.github.io/mill/mill/Plugin_Bloop.html">Mill Bloop plugin</a>. As with the previous <code>GenIdea</code> target, you must generate the Bloop configuration files with the following command (<a href="https://com-lihaoyi.github.io/mill/mill/Plugin_BSP.html">more information</a>):</p> 
<pre><code class="language-shell">./mill --import ivy:com.lihaoyi::mill-contrib-bloop:  mill.contrib.bloop.Bloop/install
</code></pre> 
<p>This seems to work well. I am able to compile, execute and debug my Scala 3 code with no problems. Scala 3's <em>"braceless"</em> syntax is also correctly recognized. Note that after every change to the Mill script, you must manually repeat the above command to export the Bloop build and reload the project in the IntelliJ IDE. Once again, you do not have direct access to Mills targets and commands via the IDE.</p> 
<p>I also use <a href="https://code.visualstudio.com/">VSCode</a>. Scala 2 and 3 is supported by the <a href="https://scalameta.org/metals/docs/editors/vscode/">Metals VSCode plugin</a> and <a href="https://com-lihaoyi.github.io/mill/mill/Plugin_Bloop.html">integration</a> is done via <a href="https://scalacenter.github.io/bloop/">Bloop</a>. Unlike IntelliJ, their is no need to install Bloop. This is <a href="https://scalameta.org/metals/docs/build-tools/mill">done automatically</a> as soon as the project is opened and the Mill build script is detected. A Bloop server will be launched and the Bloop project files generated and used. Wth this setup you have a fully functioning IDE that can compile and execute your code and unit tests. As with the IntelliJ case, you don't have direct access to the script's tasks, but you can (as in IntelliJ's case) use Mill simultaneously in a separate terminal.</p> 
<p>With the suggestions I provide here you can now productively work on your Scala 2 and 3 projects. Note that these are suggestions, but you are free to use other editors (such Sublime, Vim, Emacs, Eclipse and some oline IDEs), many of which are also supported by Metals, albeit with varying degrees of maturity. As a final comment, I have found IntelliJ's IDE perform better in 2 areas: debugging and working with Java code. The latter is important when working with mixed language projects and also projects that require debugging or exploring Java libraries. On the contrary, I find VSCode's support for editing and proofreading <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> files better.</p> 
<h2>Searching for library updates</h2> 
<p>We finish off with a utility command <code>showUpdates</code> that may be useful for the larger and more mature projects. It <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_search_for_dependency_updates">looks for dependencies that have been updated</a> and lists them. Below is the command:</p> 
<pre><code class="language-shell">$ ./mill mill.scalalib.Dependency/showUpdates
</code></pre> 
<p>and for the <a href="https://github.com/hmf/javaFXMill">example project</a> the output was:</p> 
<blockquote> 
 <pre><code>[2/2] mill.scalalib.Dependency.showUpdates 
Found 2 dependency update for javafx
  org.openjfx:javafx-controls : 16 -&gt; 17 -&gt; 17.0.0.1 -&gt; 17.0.1 -&gt; 17.0.2 -&gt; 18
  org.controlsfx:controlsfx : 11.1.0 -&gt; 11.1.1
Found 2 dependency update for managed
  org.openjfx:javafx-controls : 16 -&gt; 17 -&gt; 17.0.0.1 -&gt; 17.0.1 -&gt; 17.0.2 -&gt; 18
  org.controlsfx:controlsfx : 11.1.0 -&gt; 11.1.1
No dependency updates found for managed.test
No dependency updates found for unmanaged
No dependency updates found for unmanaged.test
</code></pre> 
</blockquote> 
<p>I know that the <a href="https://github.com/scala-steward-org/scala-steward">Scala Steward</a> project can also be used to <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Millhtml#_keeping_up_to_date_with_scala_steward">check for updates and generate pull requests</a> automatically. I have not experimented with this, but <a href="https://github.com/scala-steward-org/scala-steward/issues/314">it works on Mill</a> <a href="https://github.com/scala-steward-org/scala-steward/pull/1478">projects too</a>. It can also be used to update the <a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html#_automatic_mill_updates">Mill version</a> itself (in .mill-version file). This may be something of interest to explore and report in the future.</p> 
<h1>Basic Java build</h1> 
<p>I have set up an equivalent Java compilation unit named <code>javafx</code>. Take a look at the <a href="https://github.com/hmf/javaFXMill">source code,</a> and you will see the same directory structure and the same application code. The differences are that we use only Java source code and the unit tests are not included, so no <code>test</code> directory is provided. So what does a Java module look like in the build script? Here is the Mill module in that script:</p> 
<pre><code class="language-scala">object javafx extends OpenJFX {
  override def mainClass: T[Option[String]] = Some("helloworld.HelloWorld")

  override def ivyDeps = Agg(
                              ivy"$CONTROLS",
                              ivy"$CONTROLSFX"
                             )

}
</code></pre> 
<p>That is it. You will notice that the main differences between this module and that of the <code>managed</code> one, are:</p> 
<ul> 
 <li>The use of the <code>OpenJFX</code> module which is in essence a <code>JavaModule</code> (more details on this later);</li> 
 <li>A missing <code>override def scalaVersion = T{ ScalaVersion }</code> method</li> 
</ul> 
<p>Note that Java projects extend the <code>JavaModule</code> and Scala projects extend the <code>ScalaModule</code>, but Mill's <code>ScalaModule</code> also inherits from the <code>JavaModule</code>. So all the configuration tasks that are available to the <code>JavaModule</code> are also available to the <code>ScalaModule</code>. More concretely, Scala projects may also override JVM related parameters. The inverse, however, is not true. The following is a minimal Java project:</p> 
<pre><code class="language-scala">object foo extends JavaModule {
  override def javacOptions = T{ Seq("-source", "11", "-target", "11", "-Xlint") }
  override def forkArgs = Seq("-Xmx4g")
  override def forkEnv = Map("HELLO_MY_ENV_VAR" -&gt; "WORLD")
}
</code></pre> 
<p>And this is a minimal example of a Scala project:</p> 
<pre><code class="language-scala">object foo extends ScalaModule {
  override def scalaVersion = "2.13.8"
  override def scalacOptions = Seq("-Ydelambdafy:inline")
  override def ammoniteVersion = "2.4.0"
}
</code></pre> 
<p>As was already pointed out, one can inherit from (<em>mix-in</em>) several Mill modules in order to provide additional functionality (for example the <code>PublishModule</code> or any of the other <a href="https://com-lihaoyi.github.io/mill/mill/Contrib_Plugins.html">third party contributions</a> that are already available). In the example project I opted to define an <code>OpenJFX</code> module that inherits from the <code>JavaModule</code>, because it allows me to override the <code>forkArgs</code> task. In this way the <code>forkArgs</code> configuration task can be made available to both Java and Scala projects simply by extending the <code>OpenJFX</code> module. In the case of Java projects, no more modules are required.</p> 
<h1>Defining and using JavaFX Dependencies</h1> 
<p>Both the <code>managed</code> and <code>javafx</code> modules that were described above inherit and use the <code>OpenJFX</code> module. The <code>OpenJFX</code> module is a trait that inherits from <code>JavaModule</code> and allows me to set up a <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_common_configuration">common configuration</a> that can be quickly and easily used to set up either a Java or Scala project. Here is the definition of the Module:</p> 
<pre><code class="language-scala">trait OpenJFX extends JavaModule {

  // Modules 

  val BASE_       = s"base"
  val CONTROLS_   = s"controls"
  val FXML_       = s"fxml"
  val GRAPHICS_   = s"graphics"
  val MEDIA_      = s"media"
  val SWING_      = s"swing"
  val WEB_        = s"web"
  val CONTROLSFX_ = s"controlsfx"

  // Extra modules
  // Note that the module name and the library name are not the same
  val controlsFXModule = "org.controlsfx.controls"

  // Module libraries 
  val BASE       = s"org.openjfx:javafx-$BASE_:$javaFXVersion"
  val CONTROLS   = s"org.openjfx:javafx-$CONTROLS_:$javaFXVersion"
  val FXML       = s"org.openjfx:javafx-$FXML_:$javaFXVersion"
  val GRAPHICS   = s"org.openjfx:javafx-$GRAPHICS_:$javaFXVersion"
  val MEDIA      = s"org.openjfx:javafx-$MEDIA_:$javaFXVersion"
  val SWING      = s"org.openjfx:javafx-$SWING_:$javaFXVersion"
  val WEB        = s"org.openjfx:javafx-$WEB_:$javaFXVersion"
  val CONTROLSFX = s"org.controlsfx:$CONTROLSFX_:$controlsFXVersion"

  // OpenFX/JavaFX libraries
  val javaFXModuleNames = Seq(BASE_, CONTROLS_, FXML_, GRAPHICS_, MEDIA_, SWING_, WEB_)

  val ivyMunit = ivy"org.scalameta::munit::$mUnitVersion"
  val ivyMunitInterface = "munit.Framework"

  val pathSeparator= File.pathSeparator

  override def forkArgs: Target[Seq[String]] = T {
    // get the managed libraries
    val allLibs: Loose.Agg[PathRef] = runClasspath()
    // get the OpenJFX and related managed libraries
    val s: Loose.Agg[String] = allLibs.map(_.path.toString())
                                      .filter{
                                         s =&gt;
                                           val t= s.toLowerCase()
                                           t.contains("javafx") || t.contains("controlsfx")
                                        }

    // Create the JavaFX module names (convention is amenable to automation)
    import scala.util.matching.Regex

    // First get the javaFX only libraries
    val javaFXLibs = raw".*javafx-(.+?)-.*".r
    val javaFXModules = s.iterator.map(m =&gt; javaFXLibs.findFirstMatchIn(m).map(_.group(1)) )
                      .toSet
                      .filter(_.isDefined)
                      .map(_.get)
    // Now generate the module names
    val modulesNames = javaFXModules.map( m =&gt; s"javafx.$m") ++
                          Seq(controlsFXModule) // no standard convention, so add it manually

    // Add to the modules list
    Seq(
        "--module-path", s.iterator.mkString( pathSeparator ), 
        "--add-modules", modulesNames.iterator.mkString(","),
        "--add-exports=javafx.controls/com.sun.javafx.scene.control.behavior=org.controlsfx.controls",
        "--add-exports=javafx.controls/com.sun.javafx.scene.control.inputmap=org.controlsfx.controls",
        "--add-exports=javafx.graphics/com.sun.javafx.scene.traversal=org.controlsfx.controls"
    ) ++
      // add standard parameters
      Seq("-Dprism.verbose = true", "-ea")
  }

}
</code></pre> 
<p>The module above consists of two parts. The first, is the set of artifact names of the JavaFX (or OpenJFX) and related libraries. Anyone that needs these libraries can extend this module, reference the required names and use them in the <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_adding_ivy_dependencies"><code>ivyDeps</code></a> definition. Note that we need only add the main library. Mill will determine what other dependencies are also required and download them accordingly. Here is an example we have already seen from the <code>managed</code> and <code>javafx</code> modules:</p> 
<pre><code class="language-scala">  override def ivyDeps = Agg(
                              ivy"$CONTROLS",
                              ivy"$CONTROLSFX"
                             )
</code></pre> 
<p>The second part overrides the <code>forkArgs</code> target task, which allows us to set-up the JVM's command line arguments. We need to add the JPM specific arguments so that the JVM can find and load the necessary modules. We may also need to tweak these parameters to open or export some packages within these modules. To automatically identify and add the modules, the script above first uses <code>runClasspath()</code> to extract the existing class path, which is determined by <code>ivyDeps</code> (we cannot use <code>ivyDeps</code> directly because it does not contain all the resolved dependencies). It then filters this classpath, which contains the full path to all the necessary artifacts, to get the corresponding artifact names (variable <code>s</code>). In the example above it looks for artifacts that contain the <code>"javafx"</code> and <code>"controlsfx"</code> substrings. From these names, it then extracts the OpenJFX module names using regular expressions (<code>javaFXModules</code> variable) and adds any other module names that are also required (<code>modulesNames</code> variable).</p> 
<p>It is important to point out that the naming convention of the modules used by various library authors, is not the same. This means that, in some cases, the module name cannot be inferred and extracted from the artifact's name. An example is the <a href="https://controlsfx.github.io/">ControlsFX</a> library use in the script above. In this case, as shown below, the module name must be defined (first line) and added explicitly (last line):</p> 
<pre><code class="language-scala">  val controlsFXModule = "org.controlsfx.controls"
  val modulesNames = javaFXModules.map( m =&gt; s"javafx.$m") ++
                        Seq(controlsFXModule) // no standard convention, so add it manually
</code></pre> 
<p>The next step is to add the module names (<code>--add-modules</code>) and the paths (<code>--module-path</code>) of their Jar archives, to the JVM's command line arguments. The code snippet below shows how the JVM's command line arguments are constructed:</p> 
<pre><code class="language-scala">    Seq(
        "--module-path", s.iterator.mkString( pathSeparator ), 
        "--add-modules", modulesNames.iterator.mkString(",")
    )
</code></pre> 
<p>If you are setting up a vanilla OpenJFX project, then that should be enough. You can now import the required packages in your Java or Scala source code and execute the application. However, you may get both compile and run time errors and must therefore export a module's package so that all its public types and members are available to one or more of the other packages. For example, the following line:</p> 
<pre><code class="language-scala">            "--add-exports=javafx.controls/javafx.scene.control.skin=ALL-UNNAMED",
</code></pre> 
<p>will let any package (<code>ALL-UNNAMED</code>) access the <code>javafx.scene.control.skin</code> package. If you use <a href="https://controlsfx.github.io/">ControlsFX</a>, then you not only provide access to the public members of some of the JavaFX packages (<code>--add-exports</code>), but you must also allow it to have access to private members (usually done via reflection) using <code>--add-exports</code>. The following is an example of what you may need to use <a href="https://controlsfx.github.io/">ControlsFX</a>:</p> 
<pre><code class="language-scala">            "--add-exports=javafx.controls/javafx.scene.control.skin=ALL-UNNAMED",
            "--add-exports=javafx.graphics/com.sun.javafx.scene=org.controlsfx.controls",
            "--add-exports=javafx.graphics/com.sun.javafx.scene.traversal=org.controlsfx.controls",

            "--add-opens=javafx.controls/com.sun.javafx.scene.control.inputmap=org.controlsfx.controls", 
            "--add-opens=javafx.base/com.sun.javafx.runtime=org.controlsfx.controls",
            "--add-opens=javafx.base/com.sun.javafx.collections=org.controlsfx.controls",
            "--add-opens=javafx.graphics/com.sun.javafx.css=org.controlsfx.controls",
            "--add-opens=javafx.graphics/com.sun.javafx.scene=org.controlsfx.controls",
            "--add-opens=javafx.graphics/com.sun.javafx.scene.traversal=org.controlsfx.controls",
            "--add-opens=javafx.graphics/javafx.scene=org.controlsfx.controls",
            "--add-opens=javafx.controls/com.sun.javafx.scene.control=org.controlsfx.controls",
            "--add-opens=javafx.controls/com.sun.javafx.scene.control.behavior=org.controlsfx.controls",
            "--add-opens=javafx.controls/javafx.scene.control.skin=org.controlsfx.controls",
            "--add-opens=javafx.controls/com.sun.javafx.scene.control.behavior=org.controlsfx.controls"
</code></pre> 
<p>Every Java or Scala library that is added to the project's dependencies may require additional packages to be exported or opened due to chained dependencies. For example, when using <a href="https://github.com/GSI-CS-CO/chart-fx">ChartFX</a>, execution failed with the error because it also accesses private members of a ControlsFX package:</p> 
<pre><code class="language-java">java.lang.IllegalAccessError: superclass access check failed: class de.gsi.chart.ui.ProfilerInfoBox$CustomBreadCrumbButton (in module de.gsi.chartfx.chart) cannot access class impl.org.controlsfx.skin.BreadCrumbBarSkin$BreadCrumbButton (in module org.controlsfx.controls) because module org.controlsfx.controls does not export impl.org.controlsfx.skin to module de.gsi.chartfx.chart
</code></pre> 
<p>In this case you can add the following JVM arguments:</p> 
<pre><code class="language-scala">            "--add-opens=org.controlsfx.controls/impl.org.controlsfx.skin=de.gsi.chartfx.chart",
            "--add-opens=javafx.graphics/javafx.scene=de.gsi.chartfx.chart",
</code></pre> 
<p>Many of the library authors will provide instructions on what packages need to be exported or opened. Note that any package that is opened (private and public members), will automatically also be exported (only public members).</p> 
<p>A small note for those of you who need to use Mill to download and use OS native libraries versions, as is the case with JavaFX. To <a href="https://github.com/com-lihaoyi/mill/pull/775">correctly download</a> the OS native artifacts, one must either inherit from <code>CoursierModule</code> or add the following code snippet to all the modules that use OS native dependencies (not required in the submodules):</p> 
<pre><code class="language-scala">  override def resolutionCustomizer: Task[Option[Resolution =&gt; Resolution]] = T.task {
    Some((_: coursier.core.Resolution).withOsInfo(coursier.core.Activation.Os.fromProperties(sys.props.toMap)))
  }
</code></pre> 
<h1>Unmanaged libraries</h1> 
<p>The use of Maven artifacts and the Ivy cache to pull in and use those required artifacts is essential for the maintenance of a Java and Scala project. But what happens when the required artifact is only available via manual download? How do we add these libraries to the Mill compilation unit? The answer is to override the <code>unmanagedClasspath</code> task. The following is an example adapted from the <a href="https://com-lihaoyi.github.io/mill/mill/Configuring_Mill.html#_unmanaged_jars">official documentation</a>:</p> 
<pre><code class="language-scala">import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "3.1.1"
  def unmanagedClasspath = T {
    if (!os.exists(millSourcePath / "lib")) Agg()
    else Agg.from(os.list(millSourcePath / "lib").map(PathRef(_)))
  }
}
</code></pre> 
<p>In the script above, we add a <code>lib</code> directory to the root path of the <code>foo</code> module. You can download and place the required Jar archives into this directory. The next step, is to configure Mill to include these files in the class path used to compile and execute the module. To do this, we need only override the <code>unmanagedClasspath</code> configuration task. The goal for this task is to return the list of paths to libraries in the <code>lib</code> directory. Once the <code>unmanagedClasspath</code> has been defined, it will be included together with the managed libraries. The path of the unmanaged libraries are also automatically propagated to any of the dependent modules and submodules.</p> 
<p>To construct the path, we first need to determine the <code>foo</code> module's root path. The <code>Module</code>'s variable <a href="https://stackoverflow.com/questions/68990936/what-is-the-preferred-way-in-mill-to-point-to-the-directory-where-build-sc-file"><code>millSourcePath</code></a> points to the module's root (not the project's root). Note that this variable is not a (configuration) task and therefore cannot be listed via Mill's <code>resolve</code> utility task, nor can it be viewed using the Mill's <code>show</code> utility task. Mill already includes the <a href="https://github.com/com-lihaoyi/os-lib">OS-Lib</a> library, and we use it to first check if a <code>foo/lib</code> directory exists. If it does not, we simply return an empty list of paths. If it does, we collect the list of paths to all the files contained in the <code>foo/lib</code> directory and returns these. Note that by default the <code>unmanagedClasspath</code> is empty, but you can always use <code>super.unmanagedClasspath()</code> to access a parents' existing list of artifacts if these need to be complemented or changed. Once we have overridden this task, we can use the <code>show</code> command, as exemplified below, to check that the path is set up correctly:</p> 
<pre><code class="language-shell">./mill show foo.unmanagedClasspath
</code></pre> 
<p>We are free to place the libraries wherever we want. You could, for example, place the libraries in the project's root. In this case the following code snippet can be used to obtain the project's root path:</p> 
<pre><code class="language-scala">val baseDir = build.millSourcePath
</code></pre> 
<p>and by substituting <code>millSourcePath</code> with <code>baseDir</code> in the code snippet above, we can place and reference a set of libraries at the project level.</p> 
<p>You can use always include the <code>unmanagedClasspath</code> task defined above in any project, irrespective of whether or not unmanaged libraries are required. Because it checks for the <code>lib</code> directory before attempting to load the artifacts, you need only create and populate the directory if and when it is required.</p> 
<p>Manually downloading the libraries is not your only option. In the <a href="https://github.com/hmf/javaFXMill">example project</a> I have also included an <code>unmanaged</code> module that is defined as follows:</p> 
<pre><code class="language-scala">object unmanaged extends OpenJFX with ScalaModule {
  def scalaVersion = T{ ScalaVersion }

  override def mainClass: T[Option[String]] = Some("helloworld.HelloWorld")

  override def unmanagedClasspath: Target[Loose.Agg[PathRef]] = T{
    import coursier._
    import coursier.parse.DependencyParser

    val controlsFXModule = dep"org.controlsfx:controlsfx:11.1.0"

    // Generate the dependencies
    val javaFXModules = javaFXModuleNames.map(
      m =&gt; Dependency(Module(org"org.openjfx", ModuleName(s"javafx-$m")), javaFXVersion)
    ) ++
      Seq(controlsFXModule)

    // Check if the libraries exist and download if they don't
    val files = Fetch().addDependencies(javaFXModules: _*).run()

    // Return the list f libraries
    val pathRefs = files.map(f =&gt; PathRef(os.Path(f)))
    Agg(pathRefs : _*)
  }

    object test extends Tests {
      def ivyDeps = Agg(ivyMunit)
      def testFramework = ivyMunitInterface
    }

}
</code></pre> 
<p>The module definition above is the same as the <code>managed</code> module, but the <code>unmanagedClasspath</code> task is used instead of the <code>ivyDeps</code> task. For demonstration purposes I used <a href="https://get-coursier.io/">Coursier</a> to download all the required libraries. We could have used any other means such as an <code>FTP</code> of <code>HTTP</code> client to download the libraries. However, Coursier allows us to automatically download all the required dependencies and cache them for future use, using the Ivy dependency manager. Using Coursier will also make it easier to describe the next example (target <code>allOS</code>). We can now use the following command to show exactly what artifacts have been downloaded and where they have been placed:</p> 
<pre><code class="language-shell">$ ./mill show unmanaged.unmanagedClasspath
</code></pre> 
<details close> <summary>List of unmanaged libraries</summary> 
 <br> 
 <blockquote> 
  <pre><code>[1/1] show 
[1/1] show &gt; [1/1] unmanaged.unmanagedClasspath 
[
  "ref:ddef4c4b:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "ref:d150f068:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "ref:c6d45ef4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16.jar",
  "ref:19dc6267:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "ref:e42f9c9c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16.jar",
  "ref:945374cf:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16.jar",
  "ref:406062e3:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16.jar",
  "ref:5fa6aaf7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "ref:3df5678c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar",
  "ref:0bc3d56f:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "ref:2b46ca60:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16-linux.jar",
  "ref:e0c0bcbc:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "ref:c7238720:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16-linux.jar",
  "ref:a9caa1a4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16-linux.jar",
  "ref:8b0370d7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16-linux.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>It is important to point out that this technique can be used in conjunction with the managed libraries by defining both the <code>ivyDeps</code> and <code>unmanagedClasspath</code> tasks. Mill will take care of combining the required libraries and construct the correct class paths. In fact, the module above still requires Scala's core libraries to compile and run. The following Mill commands shows that those libraries are indeed added to the class path (in this example both runtime and compile class paths are the same, which is not always true):</p> 
<pre><code class="language-shell">$ ./mill show unmanaged.runClasspath
$ ./mill show unmanaged.compileClasspath
</code></pre> 
<details close> <summary>List of managed and unmanaged libraries</summary> 
 <br> 
 <blockquote> 
  <pre><code>[1/1] show 
[1/1] show &gt; [36/36] unmanaged.runClasspath 
[
  "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/unmanaged/resources",
  "ref:04bff8b4:/home/user/VSCodeProjects/javaFXMill/out/unmanaged/compile.dest/classes",
  "ref:ddef4c4b:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "ref:d150f068:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "ref:c6d45ef4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16.jar",
  "ref:19dc6267:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "ref:e42f9c9c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16.jar",
  "ref:945374cf:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16.jar",
  "ref:406062e3:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16.jar",
  "ref:5fa6aaf7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "ref:3df5678c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar",
  "ref:0bc3d56f:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "ref:2b46ca60:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16-linux.jar",
  "ref:e0c0bcbc:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "ref:c7238720:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16-linux.jar",
  "ref:a9caa1a4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16-linux.jar",
  "ref:8b0370d7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16-linux.jar",
  "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
  "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>As was previously mentioned, to be able to provide a <em>"fat"</em> JAR that allows us to create a truly cross-platform application, we need to download native binary libraries for the supported operating systems. The attentive reader will have noticed that I have run these examples in Linux because the Linux binary native libraries are included in the class path (in the list above, the files names have the <code>-linux</code> substring in their names). I have created an <code>allOS</code> module that allows a developer to define the OS systems that should be supported and download their OS specific dependencies automatically. To show how to download these native operating system dependencies via <a href="https://get-coursier.io/">Coursier</a>, I have the target <code>osClasspath</code> that one can execute as follows:</p> 
<pre><code class="language-shell">$ ./mill -i show allOS.osClasspath
</code></pre> 
<details close> <summary>And we get the following list of URLs for the artifacts:</summary> 
 <br> 
 <blockquote> 
  <pre><code>[1/1] show 
[1/1] show &gt; [1/1] allOS.osClasspath 
[
  "Current = Os(Some(amd64), HashSet(unix), Some(linux), Some(5.13.0-40-generic))",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-win.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16-win.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-mac.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-fxml/16/javafx-fxml-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16-linux.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-swing/16/javafx-swing-16-win.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16-win.jar",
  "https://repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-media/16/javafx-media-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-win.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-web/16/javafx-web-16-win.jar",
  "https://repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-win.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>In the list above we can see the artifacts for both Windows (<code>win</code>) and MacOS ('mac`). Here is the code snippet of the target's Mill script:</p> 
<pre><code class="language-scala">  def osClasspath: Target[Seq[String]] = T{
    implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global

    // Extra OpenFX library
    val controlsFXModule = dep"org.controlsfx:controlsfx:11.1.0"

    val current = coursier.core.Activation.Os.fromProperties(sys.props.toMap)
    // Generate the dependencies
    val javaFXModules = javaFXModuleNames.map(
      m =&gt; Dependency(Module(org"org.openjfx", ModuleName(s"javafx-$m")), javaFXVersion)
    ) ++
      Seq(controlsFXModule)

    val deps = javaFXModules
    val resWin: Future[Resolution] =
                          resolveWin
                              .addDependencies(deps: _*)
                              .future()
    val resMac: Future[Resolution] =
                          resolveMac
                              .addDependencies(deps: _*)
                              .future()
   val resLinux: Future[Resolution] =
                          resolveLinux
                            .addDependencies(deps: _*)
                            .future()

   val res = Future.sequence( List(resWin, resMac, resLinux) )
   val result = Await.result(res, Duration.Inf)
   val urls = result.map(_.dependencyArtifacts().map(_._3.url).toSet).reduceLeft((acc,s) =&gt; acc ++ s)

   s"Current = $current" :: urls.toList
  }
</code></pre> 
<p>In the code above, I first obtain the host operating system's (OS) name that is stored in the <code>current</code> variable. This is placed at the start of the target's output and helps a developer debug the Mill scripts. In the example above we see that the script was executed in the Linux OS running on an AMD64 architecture. We then use the full list of JavaFX module names <code>javaFXModuleNames</code> to generate the dependency definitions of these modules. Note that we also add the <code>controlsFXModule</code> to the final list of modules. We really only needed to use this module because Coursier automatically determines what javaFX libraries are strictly necessary. We then create 3 Coursier <code>Resolution</code> objects (<code>resWin</code>, <code>resMac</code> and <code>resLinux</code>) to load the same dependencies (<code>dep</code>), each for a different OS (Windows, MacOS and Linux respectively). We initialize the asynchronous downloads (via Scala <code>Future</code>) of the dependencies for each OS using the defined resolution object and wait indefinitely for these to finish. After the downloads finish, we extract the resolved URLs and return those as the task's results. From the output above we see that we have the native OS libraries for Windows, MacOS and Linux.</p> 
<p>The code snippet below shows how we define a Coursier <code>Resolution</code> object for Windows (see the example code for the Linux and Windows cases):</p> 
<pre><code class="language-scala">  val winX64 =Activation.Os(
    Some("x86_64"),
    Set("windows"),
    Some("windows"),
    None
  )

  val resolveWin = Resolve()
    .withResolutionParams(
      ResolutionParams()
        .withOsInfo {
          winX64
        }
    )
</code></pre> 
<p>To generate a <em>"fat"</em> Jar we need only change the <code>unmanagedClasspath</code> task to download the native OS libraries. The artifacts for the host OS can be downloaded via the standard <code>ivyDeps</code> method shown below:</p> 
<pre><code class="language-scala">  override def ivyDeps = Agg( ivy"$CONTROLS", ivy"$CONTROLSFX" )
</code></pre> 
<p>This means that we need only set-up the Coursier <code>Fetch</code> objects to use the <code>ResolutionParams</code> for the missing <code>Activation.OS</code> objects. The code snippet below shows the <code>unmanagedClasspath</code> task.</p> 
<pre><code class="language-scala">  override def unmanagedClasspath: Target[Loose.Agg[PathRef]] = T{

    import coursier.params.ResolutionParams

    // Get the name of the current (host) OS
    val osName = coursier.core.Activation.Os.fromProperties(sys.props.toMap).name.get

    // Extra OpenFX library
    // Coursier: only a single String literal is allowed here, so cannot decouple version
    val controlsFXModule = dep"org.controlsfx:controlsfx:11.1.0"

    // Generate the dependencies
    val javaFXModuleNames = Seq( CONTROLS_ )
    val javaFXModules = javaFXModuleNames.map(
      m =&gt; Dependency(Module(org"org.openjfx", ModuleName(s"javafx-$m")), javaFXVersion)
    ) ++
      Seq(controlsFXModule)

    // Setup resolution Windows downloads (if not current OS)
    val filesWin =
      if (osName != winX64.name.get) {
        Fetch()
        .addDependencies(javaFXModules: _*)
        .withResolutionParams( ResolutionParams().withOsInfo{ winX64 })
        .addArtifactTypes(Type.all)
        .run()
        .toSet
      } else Set[File]()

    // Setup resolution MacOS downloads (if not current OS)
    val filesMac =
      if (osName != macOSx64.name.get) {
        Fetch()
        .addDependencies(javaFXModules: _*)
        .withResolutionParams(ResolutionParams().withOsInfo { macOSx64 })
        .addArtifactTypes(Type.all)
        .run()
        .toSet
      } else Set[File]()

    // Setup resolution Linux downloads (if not current OS)
    val filesLinux =
      if (osName != linuxX64.name.get) {
        Fetch()
        .addDependencies(javaFXModules: _*)
        .withResolutionParams(ResolutionParams().withOsInfo { linuxX64 })
        .addArtifactTypes(Type.all)
        .run()
        .toSet
      } else Set[File]()

    val allOS = filesWin ++ filesMac ++ filesLinux
    val files = allOS.toSeq

    // Return the list of libraries
    val pathRefs = files.map(f =&gt; PathRef(os.Path(f)))
    Agg(pathRefs : _*)
  }
</code></pre> 
<p>The target above uses the same list of dependencies as the managed <code>ivyDeps</code> library. It creates <code>Fetch</code> objects for the non-host operating systems and synchronously downloads the resolved artifacts. At the end of the method, the lists of all the downloaded artifacts are merged and returned as output. The resolution parameters use the same <code>Activation.OS</code> that were used in the <code>osClasspath</code> target, so only Windows, MacOs and Linux are supported. To run the above target execute the following command:</p> 
<pre><code class="language-shell">$ ./mill -i show allOS.unmanagedClasspath
</code></pre> 
<details close> <summary>The following list of artifacts are downloaded:</summary> 
 <br> 
 <blockquote> 
  <pre><code>Compiling /home/user/VSCodeProjects/javaFXMill/build.sc
[1/1] show 
[1/1] show &gt; [1/1] allOS.unmanagedClasspath 
[
  "ref:27b03bb6:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-mac.jar",
  "ref:9cc4c083:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-mac.jar",
  "ref:ddef4c4b:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "ref:5fa6aaf7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "ref:19dc6267:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "ref:352e8fdb:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-mac.jar",
  "ref:b70cffea:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-win.jar",
  "ref:6087dd8c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-win.jar",
  "ref:d150f068:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "ref:2ec9c6a2:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-win.jar"
]
</code></pre> 
 </blockquote> 
</details> 
<p><br></p> 
<p>One can see that, not only are the <a href="https://controlsfx.github.io/">ControlsFX</a> and JavaFX Controls artifacts downloaded, but so are the JavaFX dependencies <code>graphics</code> and <code>base</code> downloaded. The OS native artifacts for MacOS and Windows are also downloaded (files names that terminate with <code>-mac</code>and <code>-win</code>). To see the full list of downloaded artifacts execute the following command:</p> 
<pre><code class="language-shell">$ ./mill -i show allOS.runClasspath
</code></pre> 
<details close> <summary>Full runtime class path:</summary> 
 <br> 
 <blockquote> 
  <pre><code>1/1] show &gt; [36/36] allOS.runClasspath 
[
  "ref:c984eca8:/home/user/VSCodeProjects/javaFXMill/allOS/resources",
  "ref:65a4706e:/home/user/VSCodeProjects/javaFXMill/out/allOS/compile.dest/classes",
  "ref:27b03bb6:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-mac.jar",
  "ref:9cc4c083:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-mac.jar",
  "ref:ddef4c4b:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "ref:5fa6aaf7:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "ref:19dc6267:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "ref:352e8fdb:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-mac.jar",
  "ref:b70cffea:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-win.jar",
  "ref:6087dd8c:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-win.jar",
  "ref:d150f068:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "ref:2ec9c6a2:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-win.jar",
  "qref:0f4aa102:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16.jar",
  "qref:347bea21:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/controlsfx/controlsfx/11.1.0/controlsfx-11.1.0.jar",
  "qref:81c212a8:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.1/scala3-library_3-3.1.1.jar",
  "qref:d8c3eec4:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-controls/16/javafx-controls-16-linux.jar",
  "qref:f52f10d0:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16.jar",
  "qref:4df2d3aa:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.6/scala-library-2.13.6.jar",
  "qref:a80bfcce:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-graphics/16/javafx-graphics-16-linux.jar",
  "qref:8f336a78:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16.jar",
  "qref:24e66df9:/home/user/.cache/coursier/v1/https/repo1.maven.org/maven2/org/openjfx/javafx-base/16/javafx-base-16-linux.jar"
]
</code></pre> 
 </blockquote>
</details>  
<p><br></p> 
<p>The astute reader will observe that Mill (circa 04-2022), when combining the <code>ivyDeps</code> and <code>unmanagedClasspath</code> artifacts, does <strong>not</strong> remove duplicates. This does not in any way prevent the applications from running correctly, but may result in very large class paths. We could filter the unwanted files at the <code>unmanagedClasspath</code> target and return only those Jars that contain native OS content. I purposely did not select the OS native artifacts, because the dependency chain may include other Jar files that do not use the same naming convention, or may include different Jars depending on the OS. One way to <em>"solve"</em> this issue is to filter out duplicates that are resolved from <code>ivyDeps</code>. To do this we simply use the <code>resolvedIvyDeps</code> target to download and filter the duplicate files as shown below:</p> 
<pre><code class="language-scala">    val deps = resolvedIvyDeps().map(_.path.toIO).iterator.toSet
    val allOS = filesWin ++ filesMac ++ filesLinux -- deps
    val files = allOS.toSeq
</code></pre> 
<p>Note that because these targets are cached, the resolution and downloading of files is only executed when necessary, otherwise the cached values are used. One should now be able to execute the applications with the following commands with the class path containing all the dependencies for all operating systems.</p> 
<pre><code class="language-shell">$ ./mill -i allOS.runMain helloworld.HelloWorld
$ ./mill -i allOS.runMain button.Main
</code></pre> 
<p>This however will not work. It is necessary to invoke the JVM with the class path that only includes the correct OS native artifacts. If multiple versions exist, the JavaFX application will fail to load. To <em>"solve"</em> this issue the <code>forkArgs</code> target of the <code>OpenJFX</code> module was changed slightly so that only the current host OS artifacts are included in the class path. The following code snippet was added to remove the non-host OS artifacts:</p> 
<pre><code class="language-scala">  // The osAll module downloads these OS native versions of the libraries
  val supported = Set("mac", "linux", "win")
  // Get the name of the current (host) OS
  val osName = coursier.core.Activation.Os.fromProperties(sys.props.toMap).name.get.toLowerCase
  // Filter for removing incompatible native OS libraries
  // If we have several native libraries for different OS, JavaFX cannot select the correct one
  val tag = osName match {
    case "linux" =&gt; "linux"
    case "mac os x" =&gt; "mac"
    case "windows" =&gt; "win"
  }
  val remove = supported - tag

  def validOS(artifact: String): Boolean = {
    if (supported.exists(s =&gt; artifact.contains(s))) {
      // Not a native OS Jar for this OS
      artifact.contains( tag )
    } else {
      // Not a native OS Jar
      true
    }
  }

  ...

  override def forkArgs: Target[Seq[String]] = T {

    ...

    // Add to the modules list
    val t = Seq(
        "--module-path", s.filter( validOS ).iterator.mkString( pathSeparator ),
        "--add-modules", modulesNames.iterator.mkString(","), // "javafx.controls,javafx.graphics,javafx.base,org.controlsfx.controls",
        "--add-exports=javafx.controls/com.sun.javafx.scene.control.behavior=org.controlsfx.controls",
        "--add-exports=javafx.controls/com.sun.javafx.scene.control.inputmap=org.controlsfx.controls",
        "--add-exports=javafx.graphics/com.sun.javafx.scene.traversal=org.controlsfx.controls"
    ) ++
      // add standard parameters
      Seq("-Dprism.verbose = true", "-ea")
    t
  }

</code></pre> 
<p>In the code snippet above, the <code>validOS</code> method checks that if an artifact is an OS dependent archive, then it is only retained if it is for the current host OS that is running the Mill script. If you will be running these applications without Mill, then you must write your own OS scripts to identify and use the correct class path.</p> 
<h1>Conclusion</h1> 
<p>In this article I have endeavoured to provide enough information for anyone to set up and use a project with several pure or mixed Scala and Java project modules using the Mill build tool. I have also focused on the use of Java Module System (JMS) because many libraries are now provided as Java modules, but not all JVM languages, such as Scala, support these natively. I used JavaFX (or OpenFX) as an example because it represents a use-case of modular libraries that requires some care in using. Finally, I have also detailed the use of unmanaged libraries. This allows us to set up projects that require Jar libraries that are not available as Maven artifacts. It also allows us to download and generate a <em>"fat"</em> Jar that contain native libraries for various operating systems. Such an application can be distributed as a single Jar and run in various operating systems. The example I provide is an OpenFX application that can be executed in several operating systems (MacOS, Windows and Linux). All the source code for this article is available in Github.</p> 
<p>The Mill build tool has been described in detail. I have included a brief history of this tool and shown how to set up and execute simple projects. I have exemplified many of Mill's utility commands that allow us to compile and run the applications. I have also demonstrated how to set up and run unit tests using MUnit. Mill also provides a set of utility commands that allow us to inspect, analyse and plot module dependencies, project variables (such as source files and dependencies) and even search for library updates. With this information you are now able to develop, debug and use your own Mill scripts.</p> 
<p>The use of an IDE is essential for developer productivity. I have shown how Mill can be used in conjunction with an editor or IDE to automate unit testing and compilation. In order to take full advantage of the IDEs, I have also shown how to import your Mill projects into the IntelliJ and VSCode IDEs using Bloop. You should now be able to develop your projects taking full advantage of the IDE.</p> 
<p>You can use the example project as a template for your Scala or Java OpenFX projects. After cloning or copying the repository, you should be able to run all the examples that were described in this article. If you find any issues or have any suggestions, feel free to open a ticket in Github's issue tracker.</p> 
<h1>References</h1> 
<ol> 
 <li><a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Understanding Java 9 Modules</a></li> 
 <li><a href="https://www.baeldung.com/java-9-modularity">A Guide to Java 9 Modularity</a></li> 
 <li><a href="https://jenkov.com/tutorials/java/modules.html">Jakob Jenkov's Java Modules tutorial</a></li> 
 <li><a href="https://docs.scala-lang.org/overviews/jdk-compatibility/overview.html">Scala compatibility with modules</a></li> 
 <li><a href="https://docs.oracle.com/en/java/javase/11/tools/jlink.html"><code>jlink</code> tool</a></li> 
 <li><a href="https://developer.ibm.com/tutorials/java-modularity-5/">Java 9+ modularity: The difficulties and pitfalls of migrating from Java 8 to Java 9+</a></li> 
 <li><a href="https://openjfx.io/openjfx-docs/#modular"><code>OpenJFX</code> module setup</a></li> 
 <li><a href="https://maven.apache.org/">Apache Maven</a></li> 
 <li><a href="https://gradle.org/">Gradle</a></li> 
 <li><a href="https://github.com/TestFX/Monocle">TestFX Monocle</a></li> 
 <li><a href="https://controlsfx.github.io/">ControlsFX</a></li> 
 <li><a href="https://github.com/GSI-CS-CO/chart-fx">Chart-FX</a></li> 
 <li><a href="https://github.com/com-lihaoyi/mill"><code>Mill</code> build tool</a></li> 
 <li><a href="https://www.scala-sbt.org/">Scala Build Tool - SBT</a></li> 
 <li><a href="https://medium.com/@ryanmyles_63493/the-best-build-tools-for-scala-language-dafa39f01936">The Best Build Tool For Scala language</a></li> 
 <li><a href="https://docs.scala-lang.org/overviews/scala-book/scala-build-tool-sbt.html">Scala Book - The most used scala build tool (sbt)</a></li> 
 <li><a href="http://sbuild.org/">SBuild - the magic-free yet powerful build tool</a></li> 
 <li><a href="https://jaxenter.com/build-tools-in-scala-144195.html">A quick tour of build tools in Scala</a></li> 
 <li><a href="https://github.com/cvogt">Jan Christopher Vogt</a></li> 
 <li><a href="https://github.com/cvogt/cbt">Chris' Build Tool (CBT) for Scala</a></li> 
 <li><a href="https://github.com/lihaoyi">Li Haoyi GitHub</a></li> 
 <li><a href="https://www.lihaoyi.com/">Li Haoyi</a></li> 
 <li><a href="https://github.com/lefou">Tobias Roeser Github</a></li> 
 <li><a href="https://com-lihaoyi.github.io/mill/mill/Intro_to_Mill.html">Mill Documentation/Introduction to Mill</a></li> 
 <li><a href="https://www.lihaoyi.com/post/MillBetterScalaBuilds.html">Mill: Better Scala Builds</a></li> 
 <li><a href="https://www.youtube.com/watch?v=j6uThGxx-18">Mill: a Build Tool based on Pure Functional Programming</a></li> 
 <li><a href="https://www.handsonscala.com/">Hands-on Scala Programming</a></li> 
 <li><a href="https://ammonite.io/">Ammonite</a></li> 
 <li><a href="https://github.com/com-lihaoyi/Ammonite">Ammonite Github</a></li> 
 <li><a href="https://www.baeldung.com/scala/ammonite-scripting">Ammonite Scripting</a></li> 
 <li><a href="https://get-coursier.io/">Coursier - Pure Scala Artifact Fetching</a></li> 
 <li><a href="https://github.com/coursier/coursier">Coursier Github</a></li> 
 <li><a href="https://github.com/scalameta/mill-scala-seed.g8">Mill Scala Seed</a></li> 
 <li><a href="https://github.com/hmf/javaFXMill">Example javaFXMill project</a></li> 
 <li><a href="https://ant.apache.org/ivy/">Ivy - The agile dependency manager</a></li> 
 <li><a href="https://scalameta.org/munit/">MUnit - Scala testing library with actionable errors and extensible APIs</a></li> 
 <li><a href="https://www.jetbrains.com/idea/">JetBrain's IntelliJ IDEA</a></li> 
 <li><a href="https://graphviz.org/">GraphViz</a></li> 
 <li><a href="https://inkscape.org/">InkScape</a></li> 
 <li><a href="https://scalameta.org/metals/docs/editors/vscode/">Metals VSCode plugin</a></li> 
 <li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li> 
 <li><a href="https://scalacenter.github.io/bloop/">Bloop build server</a></li> 
 <li><a href="https://github.com/GSI-CS-CO/chart-fx">ChartFX</a></li> 
</ol> 
<div class="footnotes"> 
 <hr> 
 <ol> 
  <li id="fn-1"> <p>Strangely their does not seem to be an official tutorial from Oracle. Some links to the OpenJDK site are available <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">here</a>.</p> <a href="#fnref-1" class="footnote-backref">↩</a> </li> 
  <li id="fn-2"> <p>I have not researched nor do I know how to implement such a solution.</p> <a href="#fnref-2" class="footnote-backref">↩</a> </li> 
  <li id="fn-3"> <p>I am not sure if the <code>dev</code> package is required, but it won't consume too much space.</p> <a href="#fnref-3" class="footnote-backref">↩</a> </li> 
  <li id="fn-4"> <p>The <code>inkview</code> command could be used, but it does <a href="https://bugs.launchpad.net/inkscape/+bug/171363">not seem to support panning and zooming</a>.</p> <a href="#fnref-4" class="footnote-backref">↩</a> </li> 
 </ol> 
</div>
    </div>
	
	<section id="social-share">
        <ul class="icons">
<!-- Social Share Button HTML -->

<!-- Twitter -->
<li><a href="//twitter.com/share?url=http://www.jbake.org/blog/2020/mill/javafx/javafx.html&text=Tutorial: JavaFX Mill project&via=" target="_blank" class="share-btn twitter">
    <i class="fa fa-twitter"></i>
    <p>Twitter</p>
</a></li>

<!-- Google Plus -->
<li><a href="//plus.google.com/share?url=http://www.jbake.org/blog/2020/mill/javafx/javafx.html" target="_blank" class="share-btn google-plus">
    <i class="fa fa-google-plus"></i>
    <p>Google+</p>
</a></li>

<!-- Facebook -->
<li><a href="//www.facebook.com/sharer/sharer.php?u=http://www.jbake.org/blog/2020/mill/javafx/javafx.html" target="_blank" class="share-btn facebook">
    <i class="fa fa-facebook"></i>
    <p>Facebook</p>
</a></li>

<!-- Reddit (url, title) -->
<li><a href="//reddit.com/submit?url=http://www.jbake.org/blog/2020/mill/javafx/javafx.html&title=Tutorial: JavaFX Mill project" target="_blank" class="share-btn reddit">
    <i class="fa fa-reddit-alien"></i>
    <p>Reddit</p>
</a></li>

<!-- LinkedIn -->
<li><a href="//www.linkedin.com/shareArticle?url=http://www.jbake.org/blog/2020/mill/javafx/javafx.html&title=Tutorial: JavaFX Mill project" target="_blank" class="share-btn linkedin">
    <i class="fa fa-linkedin"></i>
    <p>LinkedIn</p>
</a></li>

<!-- StumbleUpon (url, title) -->
<li><a href="//www.stumbleupon.com/submit?url=http://www.jbake.org/blog/2020/mill/javafx/javafx.html&title=Tutorial: JavaFX Mill project" target="_blank" class="share-btn stumbleupon">
    <i class="fa fa-stumbleupon"></i>
    <p>StumbleUpon</p>
</a></li>

<!-- Email -->
<li><a href="mailto:?subject=Check out this post by Hugo Ferreira&body=http://www.jbake.org/blog/2020/mill/javafx/javafx.html" target="_blank" class="share-btn email">
    <i class="fa fa-envelope"></i>
    <p>Email</p>
</a></li>
        </ul>
    </section>
     

    <footer>
	
		<ul class="stats">
    	    <!-- Display the categories associated with this post -->
    	    <li><i class="fa fa-tags">&nbsp;</i>  Tags: </li>
 	        <li><a href='../tags/Scala.html'>Scala</a></li>
 	        <li><a href='../tags/Mill.html'>Mill</a></li>
 	        <li><a href='../tags/JavaFX.html'>JavaFX</a></li>
 	        <li><a href='../tags/OpenFX.html'>OpenFX</a></li>

 		</ul>
    	
    </footer>
</article>
		
<ul class="actions pagination">
    	    	
	        <li><a href="../" 
	                class=" button big previous">PREVIOUS</a></li>
	   
	    	<li><span
	                class="button big"> 2 of 6 </span></li>
	                
	        <li><a href="../3/" 
	                class=" button big next">NEXT</a></li>
	
</ul>
	 </div>
	
<!-- Sidebar -->
<section id="sidebar">

    <!-- Intro -->
        <section id="intro">
                                    <img src="../img/main/icon.png" width="75px" alt="Tech 4 R&D Blog" />

                <header>
                    <h2>Tech 4 R&D</h2>
                    <p>A technical blog on all things software and hardware.</p>
                </header>

            <ul class="icons">
                    <li><a href="feed.xml" type="application/rss+xml"
                        target="_blank" title="RSS" class="fa fa-rss"></a></li>
<li><a href="//github.com/hmf" target="_blank" title="GitHub" class="fa fa-github"></a></li>













<li><a href="//medium.com/@hugo6ferreira" target="_blank" title="Medium" class="fa fa-medium"></a></li>




<li><a href="//linkedin.com/in/hugo-ferreira-289a4251" target="_blank" title="LinkedIn" class="fa fa-linkedin"></a></li>


<li><a href="//stackoverflow.com/users/2051561" target="_blank" title="Stack Overflow" class="fa fa-stack-overflow"></a></li>






            </ul>
        </section>

    <!-- Posts List -->
        <section id="recent-posts">
            <ul class="posts">
                <header>
                    <h3>Recent Posts</h3>
                </header>

                    <li>
                        <article>
                            <header>
                                <h3><a href="../blog/2020/mill/jbake/mill_mdoc_part_1.html">Tutorial: Publishing your own Github blog</a></h3>
                                 <time class="published"
							            datetime='Sep 10, 2022'>
							            Sep 10, 2022</time>
                            </header>
                        </article>
                    </li>

                    <li>
                        <article>
                            <header>
                                <h3><a href="../blog/2020/mill/javafx/javafx.html">Tutorial: JavaFX Mill project</a></h3>
                                 <time class="published"
							            datetime='Jun 09, 2022'>
							            Jun 09, 2022</time>
                            </header>
                        </article>
                    </li>


            </ul>
        </section>

    <!-- Tags List can be show/hide from config-->
        <section id="tags">
            <ul class="posts">
                <header>
                    <h3>Tags</h3>
                </header>

                    <li>
                        <article>
                            <header>
                                <a href="../tags/JavaFX.html">JavaFX</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 1 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/asciidoc.html">asciidoc</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 2 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/JBake.html">JBake</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 1 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/OpenFX.html">OpenFX</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 1 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/Scala.html">Scala</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 1 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/Mill.html">Mill</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 2 </span>
                            </header>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <a href="../tags/blog.html">blog</a>
                                <!-- JBake 2.5.1 Issue#357 prevents accessing db, If you are using 2.5.1 or earlier comment below SPAN element. -->
                                <span style="float:right;"> 4 </span>
                            </header>
                        </article>
                    </li>
            </ul>
        </section>


    <!-- About -->
        <section class="blurb">
            <h2>About</h2>
            <p>A blog with technical articles on programming, software engineering, artificial intelligence and electronics.</p>

            <ul class="actions">
                <li><a href="../about.html" class="button">Learn More</a></li>
            </ul>
        </section>


        <section id="footer">
            <p class="copyright">&copy; Tech 4 R&D. Design: <a href="http://html5up.net" target="_blank">HTML5 UP</a>. Ported For SSG by <a href="https://github.com/jpescador/hugo-future-imperfect">Julio Pescador</a>. Adapted to JBake by <a href="//github.com/manikmagar" target="_blank">Manik Magar</a>. Baked with <a href="http://jbake.org">JBake v2.6.7</a>.
            <a href="/sitemap.xml" target="_blank">Sitemap</a>.</p>
        </section>

</section>
		</div>
		<a id="back-to-top" href="#" class="fa fa-arrow-up fa-border fa-2x"></a>
		<div id="push"></div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

		<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>
		<script src="../js/skel.min.js"></script>
		<script src="../js/util.js"></script>
		<script src="../js/main.js"></script>
		<script src="../js/backToTop.js"></script>
		<script src="../js/highlight.min.js"></script>
		<script src="../js/readingTime.js"></script>
		<script src="../js/darkmode.js"></script>

		<!-- This is called by default since this theme uses highlight.js -->
		<script>hljs.highlightAll();</script>
		<!--[if lte IE 8]><script src="/js/ie/respond.min.js"></script><![endif]-->

  </body>
</html>
